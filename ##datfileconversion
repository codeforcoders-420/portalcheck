import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.*;
import java.nio.file.Path;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Compare an Excel sheet to a SQL Server SELECT query result.
 *
 * Outputs:
 *  - Summary
 *  - MissingInDB: rows in Excel absent from DB (join on KEY_COLUMNS)
 *  - Mismatches: rows where keys match but one or more non-key columns differ.
 *
 * Notes:
 *  - KEY_COLUMNS must define how to match Excel rows to DB rows.
 *  - Your SQL (TARGET_SOURCE_SQL) must return the same column names as the Excel headers.
 *  - Uses Windows authentication (pick the proper JDBC URL).
 */
public class ExcelVsSqlQueryCompareWithMismatches {

    /* ===================== USER SETTINGS ===================== */

    // Excel input
    private static final Path EXCEL_PATH = Path.of("C:/temp/input.xlsx");
    private static final String SHEET_NAME = "Source M";  // change as needed

    // Your SQL SELECT (alias columns to match Excel headers)
    private static final String TARGET_SOURCE_SQL = """
        SELECT
            [Year Applied],
            [NBU start date],
            [NBU term date],
            [RVS ID],
            [Procedure Code],
            [Modifier],
            [Status Indicator],
            [Work GPCI (2.3)],
            [Practice Expense GPCI (2.3)],
            [Malpractice GPCI (2.3)]
        FROM dbo.YourTargetTable
        WHERE SomeFilter = 1
        """;

    // SQL Server connection (choose ONE)
    // (A) Native Integrated Security (requires sqljdbc_auth.dll on PATH; arch must match JVM)
    private static final String JDBC_URL =
        "jdbc:sqlserver://YOUR_SERVER;databaseName=YOUR_DB;" +
        "encrypt=true;trustServerCertificate=true;" +
        "integratedSecurity=true;authenticationScheme=NativeAuthentication";

    // (B) Azure AD Integrated (no DLL)
    // private static final String JDBC_URL =
    //     "jdbc:sqlserver://YOUR_SERVER;databaseName=YOUR_DB;" +
    //     "encrypt=true;trustServerCertificate=true;authentication=ActiveDirectoryIntegrated";

    // Match behavior: set the columns that uniquely identify a row.
    // If left empty -> ALL columns are used as keys -> no mismatch rows by design.
    private static final Set<String> KEY_COLUMNS = Set.of(
        "RVS ID", "Procedure Code", "Modifier"  // <-- change to your real keys
    );

    // Output file
    private static final String OUTPUT_XLSX = "C:/temp/ExcelVsDB_Check.xlsx";

    // Insert batch size
    private static final int BATCH = 2000;

    /* ===================== MAIN ===================== */

    public static void main(String[] args) throws Exception {
        ExcelData excel = readExcel(EXCEL_PATH, SHEET_NAME);
        if (excel.headers.isEmpty()) {
            System.err.println("No headers found in Excel. Aborting.");
            return;
        }
        System.out.printf("Loaded Excel: %,d rows, %,d columns%n", excel.rows.size(), excel.headers.size());

        try (Connection con = DriverManager.getConnection(JDBC_URL)) {
            con.setAutoCommit(false);

            String stage = "#stage_" + UUID.randomUUID().toString().replace("-", "");
            createStageTable(con, stage, excel.headers);
            insertStage(con, stage, excel.headers, excel.rows);
            con.commit();

            List<Map<String,String>> missing = findMissing(con, stage, excel.headers);
            List<MismatchRow> mismatches = findMismatches(con, stage, excel.headers);

            writeOutput(excel.headers, missing, mismatches, OUTPUT_XLSX);

            System.out.println("Missing rows: " + missing.size());
            System.out.println("Mismatch rows: " + mismatches.size());
            System.out.println("Result written to: " + OUTPUT_XLSX);
        }
    }

    /* ===================== EXCEL READ ===================== */

    private record ExcelData(List<String> headers, List<List<String>> rows) {}

    private static ExcelData readExcel(Path path, String sheetName) throws IOException {
        try (InputStream is = new FileInputStream(path.toFile());
             Workbook wb = new XSSFWorkbook(is)) {

            Sheet sh = (sheetName == null || sheetName.isBlank()) ? wb.getSheetAt(0) : wb.getSheet(sheetName);
            if (sh == null) throw new IllegalArgumentException("Sheet not found: " + sheetName);

            // headers
            Row hrow = sh.getRow(sh.getFirstRowNum());
            if (hrow == null) throw new IllegalStateException("Header row not found.");
            List<String> headers = new ArrayList<>();
            for (int c = 0; c < hrow.getLastCellNum(); c++) {
                String name = getString(hrow.getCell(c));
                if (name == null || name.isBlank()) name = "COL_" + (c + 1);
                headers.add(name.trim());
            }

            // rows
            List<List<String>> rows = new ArrayList<>();
            for (int r = sh.getFirstRowNum() + 1; r <= sh.getLastRowNum(); r++) {
                Row row = sh.getRow(r);
                if (row == null) continue;
                List<String> vals = new ArrayList<>(headers.size());
                boolean any = false;
                for (int c = 0; c < headers.size(); c++) {
                    String v = getString(row.getCell(c));
                    if (v != null && !v.isBlank()) any = true;
                    vals.add(safe(v));
                }
                if (any) rows.add(vals);
            }
            return new ExcelData(headers, rows);
        }
    }

    private static String getString(Cell cell) {
        if (cell == null) return null;
        return switch (cell.getCellType()) {
            case STRING -> cell.getStringCellValue();
            case NUMERIC -> {
                double d = cell.getNumericCellValue();
                long l = (long) d;
                yield (d == l) ? Long.toString(l) : Double.toString(d);
            }
            case BOOLEAN -> Boolean.toString(cell.getBooleanCellValue());
            case FORMULA -> {
                try { yield cell.getStringCellValue(); }
                catch (Exception e) { yield Double.toString(cell.getNumericCellValue()); }
            }
            default -> null;
        };
    }

    /* ===================== SQL STAGE ===================== */

    private static void createStageTable(Connection con, String stage, List<String> headers) throws SQLException {
        String cols = headers.stream()
                .map(ExcelVsSqlQueryCompareWithMismatches::sqlCol)
                .map(c -> c + " NVARCHAR(4000) NULL")
                .collect(Collectors.joining(","));
        String sql = "CREATE TABLE " + stage + " (" + cols + ")";
        try (Statement st = con.createStatement()) { st.execute(sql); }
    }

    private static void insertStage(Connection con, String stage, List<String> headers, List<List<String>> rows) throws SQLException {
        String placeholders = headers.stream().map(h -> "?").collect(Collectors.joining(","));
        String colList = headers.stream().map(ExcelVsSqlQueryCompareWithMismatches::sqlCol).collect(Collectors.joining(","));
        String sql = "INSERT INTO " + stage + " (" + colList + ") VALUES (" + placeholders + ")";
        try (PreparedStatement ps = con.prepareStatement(sql)) {
            int count = 0;
            for (List<String> r : rows) {
                for (int i = 0; i < headers.size(); i++) ps.setString(i + 1, r.get(i));
                ps.addBatch();
                if (++count % BATCH == 0) ps.executeBatch();
            }
            ps.executeBatch();
        }
    }

    /* ===================== EXISTENCE CHECK ===================== */

    private static List<Map<String,String>> findMissing(Connection con, String stage, List<String> headers) throws SQLException {
        Set<String> joinCols = resolveJoinCols(headers);

        String on = joinCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '') = ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" AND "));

        String firstJoin = joinCols.iterator().next();

        String selectCols = headers.stream()
                .map(h -> "s." + sqlCol(h) + " AS " + sqlCol(h))
                .collect(Collectors.joining(", "));

        String sql = """
            SELECT %s
            FROM %s s
            LEFT JOIN (
                %s
            ) t ON %s
            WHERE t.%s IS NULL
            """.formatted(selectCols, stage, TARGET_SOURCE_SQL, on, sqlCol(firstJoin));

        List<Map<String,String>> out = new ArrayList<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) {
                Map<String,String> row = new LinkedHashMap<>();
                for (String h : headers) row.put(h, rs.getString(h));
                out.add(row);
            }
        }
        return out;
    }

    /* ===================== MISMATCH CHECK ===================== */

    private static class MismatchRow {
        String mismatchedColumns;                 // comma-separated list
        Map<String,String> excelValues = new LinkedHashMap<>(); // s.*
        Map<String,String> dbValues    = new LinkedHashMap<>(); // t.*
    }

    private static List<MismatchRow> findMismatches(Connection con, String stage, List<String> headers) throws SQLException {
        Set<String> joinCols = resolveJoinCols(headers);
        // Non-key columns to compare for mismatches
        List<String> compareCols = headers.stream()
                .filter(h -> joinCols.stream().noneMatch(k -> k.equalsIgnoreCase(h)))
                .collect(Collectors.toList());

        if (compareCols.isEmpty()) {
            // If you join on all columns, there can't be mismatches by definition.
            return List.of();
        }

        String on = joinCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '') = ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" AND "));

        // Any difference across non-key columns
        String anyDiff = compareCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '') <> ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" OR "));

        // Select stage and db copies with aliases
        String selectStage = headers.stream()
                .map(h -> "s." + sqlCol(h) + " AS " + bracket("s_" + h))
                .collect(Collectors.joining(", "));
        String selectDb = headers.stream()
                .map(h -> "t." + sqlCol(h) + " AS " + bracket("t_" + h))
                .collect(Collectors.joining(", "));

        String sql = """
            SELECT %s, %s
            FROM %s s
            INNER JOIN (
                %s
            ) t ON %s
            WHERE %s
            """.formatted(selectStage, selectDb, stage, TARGET_SOURCE_SQL, on, anyDiff);

        List<MismatchRow> out = new ArrayList<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) {
                MismatchRow mr = new MismatchRow();

                // Build maps and mismatched list (using the same normalization)
                List<String> mismCols = new ArrayList<>();
                for (String h : headers) {
                    String sVal = rs.getString("s_" + h);
                    String tVal = rs.getString("t_" + h);
                    mr.excelValues.put(h, sVal);
                    mr.dbValues.put(h, tVal);
                }
                for (String h : compareCols) {
                    String sv = norm(mr.excelValues.get(h));
                    String tv = norm(mr.dbValues.get(h));
                    if (!Objects.equals(sv, tv)) mismCols.add(h);
                }
                mr.mismatchedColumns = String.join(", ", mismCols);
                out.add(mr);
            }
        }
        return out;
    }

    /* ===================== OUTPUT ===================== */

    private static void writeOutput(List<String> headers,
                                    List<Map<String,String>> missing,
                                    List<MismatchRow> mismatches,
                                    String outPath) throws IOException {

        try (Workbook wb = new XSSFWorkbook()) {
            // Summary
            Sheet sum = wb.createSheet("Summary");
            Row h = sum.createRow(0);
            h.createCell(0).setCellValue("Metric"); h.createCell(1).setCellValue("Count");
            Row r1 = sum.createRow(1);
            r1.createCell(0).setCellValue("MissingInDB");
            r1.createCell(1).setCellValue(missing.size());
            Row r2 = sum.createRow(2);
            r2.createCell(0).setCellValue("Mismatches");
            r2.createCell(1).setCellValue(mismatches.size());
            sum.autoSizeColumn(0); sum.autoSizeColumn(1);

            // MissingInDB
            Sheet miss = wb.createSheet("MissingInDB");
            Row mh = miss.createRow(0);
            for (int c = 0; c < headers.size(); c++) mh.createCell(c).setCellValue(headers.get(c));
            int r = 1;
            for (Map<String,String> row : missing) {
                Row x = miss.createRow(r++);
                int c = 0;
                for (String hname : headers) x.createCell(c++).setCellValue(safe(row.get(hname)));
            }
            for (int c = 0; c < headers.size(); c++) miss.autoSizeColumn(c);

            // Mismatches
            Sheet diff = wb.createSheet("Mismatches");
            // Header: Mismatched Columns | (Excel.<col> ...) | (DB.<col> ...)
            Row dh = diff.createRow(0);
            int c = 0;
            dh.createCell(c++).setCellValue("Mismatched Columns");
            for (String hname : headers) dh.createCell(c++).setCellValue("Excel." + hname);
            for (String hname : headers) dh.createCell(c++).setCellValue("DB." + hname);

            int rr = 1;
            for (MismatchRow mr : mismatches) {
                Row row = diff.createRow(rr++);
                int cc = 0;
                row.createCell(cc++).setCellValue(mr.mismatchedColumns);
                for (String hname : headers) row.createCell(cc++).setCellValue(safe(mr.excelValues.get(hname)));
                for (String hname : headers) row.createCell(cc++).setCellValue(safe(mr.dbValues.get(hname)));
                if (rr % 2000 == 0) System.gc(); // tiny guard for very wide sheets
            }
            for (int i = 0; i < 1 + headers.size() * 2; i++) diff.autoSizeColumn(i);

            // Save
            try (OutputStream os = new FileOutputStream(outPath)) { wb.write(os); }
        }
    }

    /* ===================== HELPERS ===================== */

    private static Set<String> resolveJoinCols(List<String> headers) {
        return KEY_COLUMNS.isEmpty()
                ? new LinkedHashSet<>(headers) // all columns -> no mismatches possible
                : headers.stream()
                         .filter(h -> KEY_COLUMNS.stream().anyMatch(k -> k.equalsIgnoreCase(h)))
                         .collect(Collectors.toCollection(LinkedHashSet::new));
    }

    private static String sqlCol(String header) { return "[" + header.replace("]", "]]") + "]"; }
    private static String bracket(String alias)  { return "[" + alias.replace("]", "]]") + "]"; }
    private static String safe(String s) { return s == null ? "" : s; }
    private static String norm(String s) { return s == null ? "" : s.trim(); }
}

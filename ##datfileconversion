import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.streaming.SXSSFSheet;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDate;
import java.time.Month;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

public class MedinatDatToExcel {

    // ---- File characteristics ----
    private static final int RECORD_LENGTH = 8;
    private static final Charset INPUT_CHARSET = StandardCharsets.UTF_8; // use Charset.forName("windows-1252") if needed

    // ---- Computed columns ----
    private static final String COL_YEAR_APPLIED = "Year Applied";
    private static final String COL_NBU_START   = "NBU start date";
    private static final String COL_NBU_TERM    = "NBU term date";
    private static final String OPEN_END_DATE   = "12/31/9999";
    private static final DateTimeFormatter US_MDYYYY = DateTimeFormatter.ofPattern("MM/dd/yyyy");

    // ---- Layout (from your screenshot) ----
    private enum FieldDef {
        UPDATE_IND(1, 1, "Update Indicator"),                // A
        NCF       (2, 7, "National Conversion Factor");      // A (decimal included)
        final int start1, length;
        final String header;
        FieldDef(int start1, int length, String header) {
            this.start1 = start1; this.length = length; this.header = header;
        }
        int start0() { return start1 - 1; }
    }

    // ---- Row model ----
    static final class RowCF {
        String updateInd;
        String ncf;         // keep as text (e.g., "32.3463")
        String yearApplied; // computed A
        String nbuStart;    // computed B
        String nbuTerm;     // computed C
    }

    public static void main(String[] args) throws Exception {
        Path inputDat   = args.length >= 1 ? Path.of(args[0]) : Path.of("C:/temp/Medinat.dat");
        Path outputXlsx = args.length >= 2 ? Path.of(args[1]) : Path.of("C:/temp/Medinat_out.xlsx");

        // 1) Read Source M (with computed columns)
        List<RowCF> sourceM = readDat(inputDat);

        // 2) Build Source WF
        List<RowCF> sourceWF = buildWF(sourceM);

        // 3) Write workbook
        writeWorkbook(outputXlsx, sourceM, sourceWF);

        System.out.println("Created: " + outputXlsx.toAbsolutePath());
    }

    // Reads dat â†’ rows for Source M
    private static List<RowCF> readDat(Path datFile) throws IOException {
        // Rule for Source M effective/term:
        //   NBU start = current quarter start; NBU term = open-end; Year applied = year(start)
        LocalDate today = LocalDate.now(ZoneId.systemDefault());
        int month = today.getMonthValue();
        int qFirstMonth = ((month - 1) / 3) * 3 + 1; // 1,4,7,10
        LocalDate qStart = LocalDate.of(today.getYear(), Month.of(qFirstMonth), 1);
        String nbuStartCommon = US_MDYYYY.format(qStart);
        String yearAppliedCommon = Integer.toString(qStart.getYear());
        String nbuTermCommon = OPEN_END_DATE;

        List<RowCF> out = new ArrayList<>(1024);
        try (BufferedReader br = Files.newBufferedReader(datFile, INPUT_CHARSET)) {
            String line;
            while ((line = br.readLine()) != null) {
                if (line.isEmpty()) continue;

                // Normalize to exactly 8 chars
                if (line.length() < RECORD_LENGTH) {
                    line = String.format("%-" + RECORD_LENGTH + "s", line);
                } else if (line.length() > RECORD_LENGTH) {
                    line = line.substring(0, RECORD_LENGTH);
                }

                RowCF r = new RowCF();
                r.updateInd = line.substring(FieldDef.UPDATE_IND.start0(), FieldDef.UPDATE_IND.start0() + FieldDef.UPDATE_IND.length).trim();
                r.ncf       = line.substring(FieldDef.NCF.start0(),        FieldDef.NCF.start0()        + FieldDef.NCF.length).trim();

                // computed
                r.nbuStart = nbuStartCommon;
                r.nbuTerm = nbuTermCommon;
                r.yearApplied = yearAppliedCommon;

                out.add(r);
            }
        }
        return out;
    }

    // Source WF: NBU start + 365 days; NBU term = open end; Year applied = year(NBU start + 365)
    private static List<RowCF> buildWF(List<RowCF> sourceM) {
        List<RowCF> out = new ArrayList<>(sourceM.size());
        for (RowCF r : sourceM) {
            RowCF c = new RowCF();
            c.updateInd = r.updateInd;
            c.ncf = r.ncf;

            try {
                LocalDate eff = LocalDate.parse(r.nbuStart, US_MDYYYY).plusDays(365);
                c.nbuStart = US_MDYYYY.format(eff);
                c.yearApplied = Integer.toString(eff.getYear());
            } catch (Exception e) {
                // fallback: keep same values if parsing fails
                c.nbuStart = r.nbuStart;
                c.yearApplied = r.yearApplied;
            }
            c.nbuTerm = OPEN_END_DATE; // always open end for WF

            out.add(c);
        }
        return out;
    }

    private static void writeWorkbook(Path outFile, List<RowCF> sourceM, List<RowCF> sourceWF) throws IOException {
        try (SXSSFWorkbook wb = new SXSSFWorkbook(500);
             OutputStream os = Files.newOutputStream(outFile)) {

            CellStyle header = makeHeaderStyle(wb);

            writeSheet(wb, "Source M", header, sourceM);
            writeSheet(wb, "Source WF", header, sourceWF);

            wb.write(os);
            wb.dispose();
        }
    }

    private static void writeSheet(SXSSFWorkbook wb, String name, CellStyle header, List<RowCF> rows) {
        Sheet sh = wb.createSheet(name);
        int r = 0;

        // Header: computed cols first (A-C), then data fields
        Row h = sh.createRow(r++);
        int c = 0;
        Cell cell = h.createCell(c++); cell.setCellValue(COL_YEAR_APPLIED); cell.setCellStyle(header);
        cell = h.createCell(c++); cell.setCellValue(COL_NBU_START); cell.setCellStyle(header);
        cell = h.createCell(c++); cell.setCellValue(COL_NBU_TERM); cell.setCellStyle(header);

        for (FieldDef f : FieldDef.values()) {
            cell = h.createCell(c++);
            cell.setCellValue(f.header);
            cell.setCellStyle(header);
        }

        // Rows
        for (RowCF rd : rows) {
            Row row = sh.createRow(r++);
            int col = 0;

            setText(row, col++, rd.yearApplied);
            setText(row, col++, rd.nbuStart);
            setText(row, col++, rd.nbuTerm);

            setText(row, col++, rd.updateInd);
            setText(row, col++, rd.ncf);

            if (r % 5000 == 0) ((SXSSFSheet) sh).flushRows(3000);
        }

        for (int i = 0; i < 3 + FieldDef.values().length; i++) {
            sh.autoSizeColumn(i);
        }
    }

    private static void setText(Row row, int col, String v) {
        if (v == null) return;
        row.createCell(col).setCellValue(v);
    }

    private static CellStyle makeHeaderStyle(Workbook wb) {
        CellStyle style = wb.createCellStyle();
        Font f = wb.createFont();
        f.setBold(true);
        style.setFont(f);
        return style;
    }
}

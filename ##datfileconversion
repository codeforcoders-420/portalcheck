/* ===================== DATA CLASS ===================== */
private static class MismatchRow {
    // The base row’s values (Excel or DB, depending on logic)
    Map<String, String> base = new LinkedHashMap<>();

    // Classification type (e.g., "New Code", "Rate Change", "Terminate")
    String type;

    // Differences text (like: "Rate1: Excel=25.00, DB=26.00; Rate2: Excel=15.0, DB=18.0")
    String differences;
}









import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.*;
import java.math.BigDecimal;
import java.nio.file.Path;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Tiered comparison Excel ↔ SQL Server using custom rules:
 *
 * 1) Remove Exact matches  : Proc, Mod, Eff, Term, Rate1..Rate5 all equal.
 * 2) Remove Partial matches: Same as above but ignoring Eff.
 * 3) Remaining Excel rows:
 *      - If (Proc+Mod) not found in DB -> New Code (Mismatches_ExcelToDB)
 *      - Else -> Rate Change (Differences lists Rate1..Rate5 deltas) (Mismatches_ExcelToDB)
 * 4) DB rows where (Proc+Mod) not found in Excel -> Terminate (Mismatches_DBToExcel)
 *
 * Assumptions:
 *  - Excel headers == SQL SELECT column names (alias in SQL if needed).
 *  - Windows authentication (pick a JDBC URL below).
 */

public class ExcelVsSqlQueryCompare_TieredRules {

    /* ===================== USER SETTINGS ===================== */

    // Excel input
    private static final Path EXCEL_PATH = Path.of("C:/temp/input.xlsx");
    private static final String SHEET_NAME = "Source M";

    // Your SQL SELECT (columns must match Excel header names!)
    private static final String TARGET_SOURCE_SQL = """
        SELECT
            [Proc],
            [Mod],
            [Eff],
            [Term],
            [Rate1],
            [Rate2],
            [Rate3],
            [Rate4],
            [Rate5]
        FROM dbo.YourTargetTable
        WHERE IsActive = 1
        """;

    // Connection (choose ONE)
    // (A) Native Integrated Security (requires sqljdbc_auth.dll on PATH; arch must match JVM):
    private static final String JDBC_URL =
        "jdbc:sqlserver://YOUR_SERVER;databaseName=YOUR_DB;" +
        "encrypt=true;trustServerCertificate=true;" +
        "integratedSecurity=true;authenticationScheme=NativeAuthentication";

    // (B) Azure AD / domain-joined Integrated (no DLL):
    // private static final String JDBC_URL =
    //     "jdbc:sqlserver://YOUR_SERVER;databaseName=YOUR_DB;" +
    //     "encrypt=true;trustServerCertificate=true;authentication=ActiveDirectoryIntegrated";

    // Column names used by rules (must exist in Excel & SQL result)
    private static final String COL_PROC = "Proc";
    private static final String COL_MOD  = "Mod";
    private static final String COL_EFF  = "Eff";
    private static final String COL_TERM = "Term";
    private static final List<String> RATE_COLS = List.of("Rate1","Rate2","Rate3","Rate4","Rate5");

    // Output
    private static final String OUTPUT_XLSX = "C:/temp/Compare_Report.xlsx";

    // Batch size
    private static final int BATCH = 2000;

    /* ===================== MAIN ===================== */

    public static void main(String[] args) throws Exception {
        ExcelData excel = readExcel(EXCEL_PATH, SHEET_NAME);
        if (!excel.headers.containsAll(requiredHeaders())) {
            throw new IllegalStateException("Excel is missing one of required headers: " + requiredHeaders());
        }

        try (Connection con = DriverManager.getConnection(JDBC_URL)) {
            con.setAutoCommit(false);

            String stage = "#stage_" + UUID.randomUUID().toString().replace("-", "");
            createStageTable(con, stage, excel.headers);
            insertStage(con, stage, excel.headers, excel.rows);
            con.commit();

            // 1) Exact matches (exclude)
            Set<Key> exactKeys = loadKeys(con, exactMatchSQL(stage));

            // 2) Partial matches ignoring Eff (exclude)
            Set<Key> partialKeys = loadKeys(con, partialMatchSQL(stage));

            // Remaining Excel rows to consider
            Set<Key> excluded = new HashSet<>(exactKeys); excluded.addAll(partialKeys);

            // 3a) New Codes: remaining Excel rows where Proc+Mod not in DB
            List<MismatchRow> newCodes = findNewCodes(con, stage, excluded, excel.headers);

            // 3b) Rate Changes: remaining Excel rows where Proc+Mod exists in DB, but rates differ
            List<MismatchRow> rateChanges = findRateChanges(con, stage, excluded, excel.headers);

            // 5) DB→Excel Terminate: DB rows whose Proc+Mod not in Excel
            List<MismatchRow> terminate = findTerminates(con, stage);

            // Write report
            writeOutput(excel.headers, newCodes, rateChanges, terminate, OUTPUT_XLSX);

            System.out.println("New Codes:      " + newCodes.size());
            System.out.println("Rate Changes:   " + rateChanges.size());
            System.out.println("Terminates:     " + terminate.size());
            System.out.println("Report: " + OUTPUT_XLSX);
        }
    }

    /* ===================== EXCEL READ ===================== */

    private record ExcelData(List<String> headers, List<List<String>> rows) {}

    private static ExcelData readExcel(Path path, String sheetName) throws IOException {
        try (InputStream is = new FileInputStream(path.toFile());
             Workbook wb = new XSSFWorkbook(is)) {

            Sheet sh = (sheetName == null || sheetName.isBlank()) ? wb.getSheetAt(0) : wb.getSheet(sheetName);
            if (sh == null) throw new IllegalArgumentException("Sheet not found: " + sheetName);

            Row hrow = sh.getRow(sh.getFirstRowNum());
            List<String> headers = new ArrayList<>();
            for (int c = 0; c < hrow.getLastCellNum(); c++) {
                String name = getString(hrow.getCell(c));
                headers.add(name == null ? ("COL_" + (c+1)) : name.trim());
            }

            List<List<String>> rows = new ArrayList<>();
            for (int r = sh.getFirstRowNum() + 1; r <= sh.getLastRowNum(); r++) {
                Row row = sh.getRow(r); if (row == null) continue;
                List<String> vals = new ArrayList<>(headers.size());
                boolean any = false;
                for (int c = 0; c < headers.size(); c++) {
                    String v = getString(row.getCell(c));
                    if (v != null && !v.isBlank()) any = true;
                    vals.add(v == null ? "" : v);
                }
                if (any) rows.add(vals);
            }
            return new ExcelData(headers, rows);
        }
    }

    private static String getString(Cell cell) {
        if (cell == null) return null;
        return switch (cell.getCellType()) {
            case STRING -> cell.getStringCellValue();
            case NUMERIC -> {
                double d = cell.getNumericCellValue();
                long l = (long) d;
                yield (d == l) ? Long.toString(l) : Double.toString(d);
            }
            case BOOLEAN -> Boolean.toString(cell.getBooleanCellValue());
            case FORMULA -> {
                try { yield cell.getStringCellValue(); }
                catch (Exception e) { yield Double.toString(cell.getNumericCellValue()); }
            }
            default -> null;
        };
    }

    /* ===================== SQL STAGING ===================== */

    private static void createStageTable(Connection con, String stage, List<String> headers) throws SQLException {
        String cols = headers.stream().map(ExcelVsSqlQueryCompare_TieredRules::b).map(c -> c + " NVARCHAR(4000) NULL").collect(Collectors.joining(","));
        try (Statement st = con.createStatement()) { st.execute("CREATE TABLE " + stage + " (" + cols + ")"); }
    }

    private static void insertStage(Connection con, String stage, List<String> headers, List<List<String>> rows) throws SQLException {
        String qMarks = headers.stream().map(h -> "?").collect(Collectors.joining(","));
        String colList = headers.stream().map(ExcelVsSqlQueryCompare_TieredRules::b).collect(Collectors.joining(","));
        String sql = "INSERT INTO " + stage + " (" + colList + ") VALUES (" + qMarks + ")";
        try (PreparedStatement ps = con.prepareStatement(sql)) {
            int cnt = 0;
            for (List<String> r : rows) {
                for (int i = 0; i < headers.size(); i++) ps.setString(i+1, r.get(i));
                ps.addBatch();
                if (++cnt % BATCH == 0) ps.executeBatch();
            }
            ps.executeBatch();
        }
    }

    /* ===================== RULE SQL BUILDERS ===================== */

    private static String eq(String left, String right) {
        return "ISNULL(LTRIM(RTRIM(" + left + ")), '') = ISNULL(LTRIM(RTRIM(" + right + ")), '')";
    }

    // 1) Exact: all nine columns equal
    private static String exactMatchSQL(String stage) {
        List<String> all = new ArrayList<>(List.of(COL_PROC, COL_MOD, COL_EFF, COL_TERM));
        all.addAll(RATE_COLS);
        String on = all.stream()
                .map(c -> eq("t." + b(c), "s." + b(c)))
                .collect(Collectors.joining(" AND "));
        return """
               SELECT s.%s, s.%s
               FROM %s s
               INNER JOIN ( %s ) t
                 ON %s
               """.formatted(b(COL_PROC), b(COL_MOD), stage, TARGET_SOURCE_SQL, on);
    }

    // 2) Partial: all except Eff equal
    private static String partialMatchSQL(String stage) {
        List<String> cols = new ArrayList<>(List.of(COL_PROC, COL_MOD, COL_TERM));
        cols.addAll(RATE_COLS);
        String on = cols.stream()
                .map(c -> eq("t." + b(c), "s." + b(c)))
                .collect(Collectors.joining(" AND "));
        return """
               SELECT s.%s, s.%s
               FROM %s s
               INNER JOIN ( %s ) t
                 ON %s
               """.formatted(b(COL_PROC), b(COL_MOD), stage, TARGET_SOURCE_SQL, on);
    }

    /* ===================== CLASSIFICATION QUERIES ===================== */

    // 3a) New Codes: remaining Excel rows; Proc+Mod not in DB
    private static List<MismatchRow> findNewCodes(Connection con, String stage, Set<Key> excluded, List<String> headers) throws SQLException {
        String onKey = eq("t." + b(COL_PROC), "s." + b(COL_PROC)) + " AND " + eq("t." + b(COL_MOD), "s." + b(COL_MOD));
        String selectStage = headers.stream().map(h -> "s." + b(h) + " AS " + b(h)).collect(Collectors.joining(", "));
        String sql = """
            SELECT %s
            FROM %s s
            LEFT JOIN ( %s ) t ON %s
            WHERE t.%s IS NULL
            """.formatted(selectStage, stage, TARGET_SOURCE_SQL, onKey, b(COL_PROC));

        List<MismatchRow> out = new ArrayList<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) {
                Key k = new Key(rs.getString(COL_PROC), rs.getString(COL_MOD));
                if (excluded.contains(k)) continue;
                MismatchRow mr = new MismatchRow();
                mr.type = "New Code";
                mr.base = readRow(rs, headers);
                mr.differences = "New code (not found in DB by Proc+Mod)";
                out.add(mr);
            }
        }
        return out;
    }

    // 3b) Rate Changes: remaining Excel rows; Proc+Mod exists in DB but any Rate differs
    private static List<MismatchRow> findRateChanges(Connection con, String stage, Set<Key> excluded, List<String> headers) throws SQLException {
        String onKey = eq("t." + b(COL_PROC), "s." + b(COL_PROC)) + " AND " + eq("t." + b(COL_MOD), "s." + b(COL_MOD));

        String selectStage = headers.stream().map(h -> "s." + b(h) + " AS " + b("s_" + h)).collect(Collectors.joining(", "));
        String selectDbRates = RATE_COLS.stream().map(h -> "t." + b(h) + " AS " + b("t_" + h)).collect(Collectors.joining(", "));
        String anyRateDiff = RATE_COLS.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(s." + b(h) + ")), '') <> ISNULL(LTRIM(RTRIM(t." + b(h) + ")), '')")
                .collect(Collectors.joining(" OR "));

        String sql = """
            SELECT %s, %s
            FROM %s s
            INNER JOIN ( %s ) t ON %s
            WHERE %s
            """.formatted(selectStage, selectDbRates, stage, TARGET_SOURCE_SQL, onKey, anyRateDiff);

        List<MismatchRow> out = new ArrayList<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) {
                Key k = new Key(rs.getString("s_" + COL_PROC), rs.getString("s_" + COL_MOD));
                if (excluded.contains(k)) continue;

                MismatchRow mr = new MismatchRow();
                mr.type = "Rate Change";
                mr.base = new LinkedHashMap<>();
                for (String h : headers) mr.base.put(h, rs.getString("s_" + h)); // Excel row as base

                // Build Differences only for Rate1..Rate5
                List<String> parts = new ArrayList<>();
                for (String rcol : RATE_COLS) {
                    String sv = norm(rs.getString("s_" + rcol));
                    String tv = norm(rs.getString("t_" + rcol));
                    if (!Objects.equals(sv, tv)) {
                        parts.add(rcol + ": Excel=" + safeForDiff(sv) + ", DB=" + safeForDiff(tv));
                    }
                }
                mr.differences = String.join("; ", parts);

                out.add(mr);
            }
        }
        return out;
    }

    // 5) DB rows not in Excel by Proc+Mod -> Terminate
    private static List<MismatchRow> findTerminates(Connection con, String stage) throws SQLException {
        String onKey = eq("t." + b(COL_PROC), "s." + b(COL_PROC)) + " AND " + eq("t." + b(COL_MOD), "s." + b(COL_MOD));
        String selectDb = """
            SELECT %s
            FROM ( %s ) t
            LEFT JOIN %s s ON %s
            WHERE s.%s IS NULL
            """.formatted(
                Stream.concat(
                    Stream.of(COL_PROC, COL_MOD, COL_EFF, COL_TERM),
                    RATE_COLS.stream()
                ).map(h -> "t." + b(h) + " AS " + b(h)).collect(Collectors.joining(", ")),
                TARGET_SOURCE_SQL, stage, onKey, b(COL_PROC)
            );

        List<MismatchRow> out = new ArrayList<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(selectDb)) {
            while (rs.next()) {
                MismatchRow mr = new MismatchRow();
                mr.type = "Terminate";
                mr.base = readRow(rs, requiredHeaders());  // DB row as base
                mr.differences = "DB has Proc+Mod not present in Excel (terminate)";
                out.add(mr);
            }
        }
        return out;
    }

    /* ===================== OUTPUT ===================== */

    private static void writeOutput(List<String> headers,
                                    List<MismatchRow> newCodes,
                                    List<MismatchRow> rateChanges,
                                    List<MismatchRow> terminates,
                                    String outPath) throws IOException {

        try (Workbook wb = new XSSFWorkbook()) {
            // Summary
            Sheet sum = wb.createSheet("Summary");
            Row h = sum.createRow(0);
            h.createCell(0).setCellValue("Category"); h.createCell(1).setCellValue("Count");
            Row r1 = sum.createRow(1); r1.createCell(0).setCellValue("New Codes");    r1.createCell(1).setCellValue(newCodes.size());
            Row r2 = sum.createRow(2); r2.createCell(0).setCellValue("Rate Changes"); r2.createCell(1).setCellValue(rateChanges.size());
            Row r3 = sum.createRow(3); r3.createCell(0).setCellValue("Terminate");    r3.createCell(1).setCellValue(terminates.size());
            sum.autoSizeColumn(0); sum.autoSizeColumn(1);

            // Mismatches_ExcelToDB
            writeMismatchSheet(wb, "Mismatches_ExcelToDB", headers, newCodes, rateChanges);

            // Mismatches_DBToExcel
            writeMismatchSheet(wb, "Mismatches_DBToExcel", headers, terminates);

            try (OutputStream os = new FileOutputStream(outPath)) { wb.write(os); }
        }
    }

    private static void writeMismatchSheet(Workbook wb, String sheetName, List<String> headers, List<MismatchRow>... groups) {
        Sheet s = wb.createSheet(sheetName);
        Row head = s.createRow(0);
        int c = 0;
        for (String h : headers) head.createCell(c++).setCellValue(h);
        head.createCell(c++).setCellValue("Type");
        head.createCell(c).setCellValue("Differences");

        int r = 1;
        for (List<MismatchRow> group : groups) {
            for (MismatchRow mr : group) {
                Row row = s.createRow(r++);
                int cc = 0;
                for (String h : headers) row.createCell(cc++).setCellValue(safe(mr.base.get(h)));
                row.createCell(cc++).setCellValue(mr.type);
                row.createCell(cc).setCellValue(mr.differences);
            }
        }
        for (int i = 0; i < headers.size() + 2; i++) s.autoSizeColumn(i);
    }

    /* ===================== HELPERS ===================== */

    private static Set<String> requiredHeaders() {
        List<String> all = new ArrayList<>(List.of(COL_PROC, COL_MOD, COL_EFF, COL_TERM));
        all.addAll(RATE_COLS);
        return new LinkedHashSet<>(all);
    }

    private static Map<String,String> readRow(ResultSet rs, List<String> headers) throws SQLException {
        Map<String,String> m = new LinkedHashMap<>();
        for (String h : headers) m.put(h, rs.getString(h));
        return m;
    }
    private static Map<String,String> readRow(ResultSet rs, Set<String> headers) throws SQLException {
        Map<String,String> m = new LinkedHashMap<>();
        for (String h : headers) m.put(h, rs.getString(h));
        return m;
    }

    private static String b(String name) { return "[" + name.replace("]", "]]") + "]"; }
    private static String safe(String s) { return s == null ? "" : s; }
    private static String norm(String s) { return s == null ? "" : s.trim(); }

    private static String safeForDiff(String s) {
        if (s == null) return "<NULL>";
        String v = s.trim();
        if (v.isEmpty()) return "<EMPTY>";
        try { v = new BigDecimal(v).stripTrailingZeros().toPlainString(); }
        catch (NumberFormatException ignore) {}
        if (v.length() > 200) v = v.substring(0,200) + "…";
        return v;
    }

    private record Key(String proc, String mod) { }
    private static Set<Key> loadKeys(Connection con, String sql) throws SQLException {
        Set<Key> out = new HashSet<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) out.add(new Key(rs.getString(COL_PROC), rs.getString(COL_MOD)));
        }
        return out;
    }
}

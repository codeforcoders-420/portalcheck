import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.*;
import java.nio.file.Path;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;

public class ExcelVsSqlExistenceCheck {

    // ====== CONFIG ======
    // Excel input
    private static final Path EXCEL_PATH = Path.of("C:/temp/input.xlsx");
    private static final String SHEET_NAME = "Source M";        // change as needed

    // SQL Server target
    // Use one of the two URLs below (uncomment the one that fits your environment):
    // Native / Integrated Security (requires sqljdbc_auth.dll in PATH):
    private static final String JDBC_URL =
            "jdbc:sqlserver://YOUR_SERVER_NAME;databaseName=YOUR_DB;encrypt=true;trustServerCertificate=true;integratedSecurity=true;authenticationScheme=NativeAuthentication";
    // Or Azure AD / domain joined (no dll): "jdbc:sqlserver://YOUR_SERVER;databaseName=YOUR_DB;encrypt=true;authentication=ActiveDirectoryIntegrated";

    private static final String TARGET_TABLE = "dbo.YourTargetTable";   // same column names as Excel headers

    // Matching behavior:
    // If empty => compare on ALL columns; otherwise only on these column names (case-insensitive).
    private static final Set<String> KEY_COLUMNS = Set.of(); // e.g., Set.of("Procedure Code","Modifier")

    // Batch size for insert
    private static final int BATCH = 2000;

    public static void main(String[] args) throws Exception {
        // 1) Read Excel
        ExcelData excel = readExcel(EXCEL_PATH, SHEET_NAME);
        if (excel.headers.isEmpty()) {
            System.out.println("No headers found, aborting.");
            return;
        }
        System.out.println("Excel rows: " + excel.rows.size());

        try (Connection con = DriverManager.getConnection(JDBC_URL)) {
            con.setAutoCommit(false);

            String stage = "#stage_" + UUID.randomUUID().toString().replace("-", "");
            createStageTable(con, stage, excel.headers);
            insertStage(con, stage, excel.headers, excel.rows);
            con.commit();

            // 2) Compare (set-based LEFT JOIN)
            List<Map<String,String>> missing = findMissing(con, stage, excel.headers);

            // 3) Write results
            writeOutput(excel.headers, missing);

            System.out.println("Done. Missing rows in DB: " + missing.size());
        }
    }

    /* ---------------- Excel read ---------------- */

    record ExcelData(List<String> headers, List<List<String>> rows) {}

    private static ExcelData readExcel(Path path, String sheetName) throws IOException {
        try (InputStream is = new FileInputStream(path.toFile());
             Workbook wb = new XSSFWorkbook(is)) {

            Sheet sh = (sheetName == null || sheetName.isBlank())
                    ? wb.getSheetAt(0)
                    : wb.getSheet(sheetName);
            if (sh == null) throw new IllegalArgumentException("Sheet not found: " + sheetName);

            // headers from row 0
            Row hrow = sh.getRow(sh.getFirstRowNum());
            List<String> headers = new ArrayList<>();
            for (int c = 0; c < hrow.getLastCellNum(); c++) {
                String name = getString(hrow.getCell(c));
                if (name == null || name.isBlank()) name = "COL_" + (c+1);
                headers.add(name.trim());
            }

            List<List<String>> rows = new ArrayList<>();
            for (int r = sh.getFirstRowNum() + 1; r <= sh.getLastRowNum(); r++) {
                Row row = sh.getRow(r);
                if (row == null) continue;
                List<String> vals = new ArrayList<>(headers.size());
                boolean any = false;
                for (int c = 0; c < headers.size(); c++) {
                    String v = getString(row.getCell(c));
                    if (v != null && !v.isBlank()) any = true;
                    vals.add(safe(v));
                }
                if (any) rows.add(vals);
            }
            return new ExcelData(headers, rows);
        }
    }

    private static String getString(Cell cell) {
        if (cell == null) return null;
        return switch (cell.getCellType()) {
            case STRING -> cell.getStringCellValue();
            case NUMERIC -> {
                double d = cell.getNumericCellValue();
                long l = (long) d;
                yield (d == l) ? Long.toString(l) : Double.toString(d);
            }
            case BOOLEAN -> Boolean.toString(cell.getBooleanCellValue());
            case FORMULA -> cell.getCellFormula();
            default -> null;
        };
    }

    /* ---------------- SQL staging ---------------- */

    private static void createStageTable(Connection con, String stage, List<String> headers) throws SQLException {
        String cols = headers.stream()
                .map(ExcelVsSqlExistenceCheck::sqlCol)
                .map(c -> c + " NVARCHAR(4000) NULL")
                .collect(Collectors.joining(","));
        String sql = "CREATE TABLE " + stage + " (" + cols + ")";
        try (Statement st = con.createStatement()) {
            st.execute(sql);
        }
    }

    private static void insertStage(Connection con, String stage, List<String> headers, List<List<String>> rows) throws SQLException {
        String placeholders = headers.stream().map(h -> "?").collect(Collectors.joining(","));
        String colList = headers.stream().map(ExcelVsSqlExistenceCheck::sqlCol).collect(Collectors.joining(","));
        String sql = "INSERT INTO " + stage + " (" + colList + ") VALUES (" + placeholders + ")";
        try (PreparedStatement ps = con.prepareStatement(sql)) {
            int count = 0;
            for (List<String> r : rows) {
                for (int i = 0; i < headers.size(); i++) {
                    ps.setString(i + 1, r.get(i));
                }
                ps.addBatch();
                if (++count % BATCH == 0) ps.executeBatch();
            }
            ps.executeBatch();
        }
    }

    /* ---------------- Compare ---------------- */

    private static List<Map<String,String>> findMissing(Connection con, String stage, List<String> headers) throws SQLException {
        // Build join condition: either all columns or a user-provided subset
        Set<String> joinCols = KEY_COLUMNS.isEmpty()
                ? new LinkedHashSet<>(headers)
                : headers.stream().filter(h -> KEY_COLUMNS.stream().anyMatch(k -> k.equalsIgnoreCase(h))).collect(Collectors.toCollection(LinkedHashSet::new));

        if (joinCols.isEmpty()) throw new IllegalStateException("No columns to join on.");

        String on = joinCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '') = ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" AND "));

        String selectCols = headers.stream()
                .map(h -> "s." + sqlCol(h) + " AS " + sqlCol(h))
                .collect(Collectors.joining(", "));

        String sql = """
                SELECT %s
                FROM %s s
                LEFT JOIN %s t ON %s
                WHERE t.%s IS NULL
                """.formatted(selectCols, stage, TARGET_TABLE, on, sqlCol(joinCols.iterator().next()));

        List<Map<String,String>> out = new ArrayList<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) {
                Map<String,String> row = new LinkedHashMap<>();
                for (String h : headers) {
                    row.put(h, rs.getString(h));
                }
                out.add(row);
            }
        }
        return out;
    }

    /* ---------------- Output Excel ---------------- */

    private static void writeOutput(List<String> headers, List<Map<String,String>> missing) throws IOException {
        try (Workbook wb = new XSSFWorkbook()) {
            // Summary
            Sheet sum = wb.createSheet("Summary");
            Row r0 = sum.createRow(0); r0.createCell(0).setCellValue("Metric"); r0.createCell(1).setCellValue("Count");
            Row r1 = sum.createRow(1); r1.createCell(0).setCellValue("MissingInDB"); r1.createCell(1).setCellValue(missing.size());
            sum.autoSizeColumn(0); sum.autoSizeColumn(1);

            // MissingInDB
            Sheet miss = wb.createSheet("MissingInDB");
            Row head = miss.createRow(0);
            for (int c = 0; c < headers.size(); c++) head.createCell(c).setCellValue(headers.get(c));
            int rr = 1;
            for (Map<String,String> row : missing) {
                Row x = miss.createRow(rr++);
                int c = 0;
                for (String h : headers) x.createCell(c++).setCellValue(safe(row.get(h)));
            }
            for (int c = 0; c < headers.size(); c++) miss.autoSizeColumn(c);

            try (OutputStream os = new FileOutputStream("C:/temp/ExcelVsDB_Check.xlsx")) {
                wb.write(os);
            }
        }
    }

    /* ---------------- helpers ---------------- */

    private static String sqlCol(String header) {
        // wrap with brackets to survive spaces/specials
        return "[" + header.replace("]", "]]") + "]";
    }
    private static String safe(String s) { return s == null ? "" : s; }
}

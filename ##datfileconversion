import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.*;
import java.nio.file.Path;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Compares an Excel sheet against a SQL Server SELECT.
 *
 * Outputs:
 *  - Summary
 *  - MissingInDB: Excel rows not found in DB (join on KEY_COLUMNS)
 *  - Mismatches: Excel rows where keys match but one or more non-key columns differ,
 *                with a single trailing "Differences" column listing mismatched column names.
 *
 * Requirements:
 *  - TARGET_SOURCE_SQL must be a single SELECT.
 *  - Columns returned by TARGET_SOURCE_SQL must match Excel headers (alias if needed).
 *  - Uses Windows authentication; pick the JDBC URL that matches your environment.
 */
public class ExcelVsSqlQueryCompare_DiffOnly {

    /* ===================== USER SETTINGS ===================== */

    // Excel input
    private static final Path EXCEL_PATH = Path.of("C:/temp/input.xlsx");
    private static final String SHEET_NAME = "Source M"; // change if needed

    // Your SQL SELECT (alias columns to match Excel headers exactly)
    private static final String TARGET_SOURCE_SQL = """
        SELECT
            [Year Applied],
            [NBU start date],
            [NBU term date],
            [RVS ID],
            [Procedure Code],
            [Modifier],
            [Status Indicator],
            [Work RVU (4.2)],
            [Non-facility Practice Expense RVS (4.2)],
            [Facility Practice Expense (4.2)],
            [Malpractice RVU (4.2)],
            [Non-facility Total RVU (4.2)],
            [Facility Total RVU (4.2)],
            [Update Indicator],
            [Global Period]
        FROM dbo.YourTargetTable
        WHERE SomeFilter = 1
        """;

    // SQL Server connection (choose ONE; comment out the other)
    // (A) Native Integrated Security (requires sqljdbc_auth.dll on PATH; architecture must match the JVM)
    private static final String JDBC_URL =
        "jdbc:sqlserver://YOUR_SERVER;databaseName=YOUR_DB;" +
        "encrypt=true;trustServerCertificate=true;" +
        "integratedSecurity=true;authenticationScheme=NativeAuthentication";

    // (B) Azure AD / domain-joined Integrated (no DLL)
    // private static final String JDBC_URL =
    //     "jdbc:sqlserver://YOUR_SERVER;databaseName=YOUR_DB;" +
    //     "encrypt=true;trustServerCertificate=true;authentication=ActiveDirectoryIntegrated";

    // Keys that uniquely identify a row for matching Excelâ†”DB
    // If left empty: ALL columns are treated as keys -> no mismatch rows by design.
    private static final Set<String> KEY_COLUMNS = Set.of(
        "RVS ID", "Procedure Code", "Modifier" // <- update to your real keys
    );

    // Output
    private static final String OUTPUT_XLSX = "C:/temp/ExcelVsDB_Check.xlsx";

    // Insert batch size
    private static final int BATCH = 2000;

    /* ===================== MAIN ===================== */

    public static void main(String[] args) throws Exception {
        ExcelData excel = readExcel(EXCEL_PATH, SHEET_NAME);
        if (excel.headers.isEmpty()) {
            System.err.println("No headers found in Excel. Aborting.");
            return;
        }
        System.out.printf("Loaded Excel: %,d rows, %,d columns%n", excel.rows.size(), excel.headers.size());

        try (Connection con = DriverManager.getConnection(JDBC_URL)) {
            con.setAutoCommit(false);

            String stage = "#stage_" + UUID.randomUUID().toString().replace("-", "");
            createStageTable(con, stage, excel.headers);
            insertStage(con, stage, excel.headers, excel.rows);
            con.commit();

            List<Map<String,String>> missing   = findMissing(con, stage, excel.headers);
            List<MismatchRow>        mismatch  = findMismatches(con, stage, excel.headers);

            writeOutput(excel.headers, missing, mismatch, OUTPUT_XLSX);

            System.out.println("Missing rows:   " + missing.size());
            System.out.println("Mismatch rows:  " + mismatch.size());
            System.out.println("Report: " + OUTPUT_XLSX);
        }
    }

    /* ===================== EXCEL READ ===================== */

    private record ExcelData(List<String> headers, List<List<String>> rows) {}

    private static ExcelData readExcel(Path path, String sheetName) throws IOException {
        try (InputStream is = new FileInputStream(path.toFile());
             Workbook wb = new XSSFWorkbook(is)) {

            Sheet sh = (sheetName == null || sheetName.isBlank()) ? wb.getSheetAt(0) : wb.getSheet(sheetName);
            if (sh == null) throw new IllegalArgumentException("Sheet not found: " + sheetName);

            // headers
            Row hrow = sh.getRow(sh.getFirstRowNum());
            if (hrow == null) throw new IllegalStateException("Header row not found.");
            List<String> headers = new ArrayList<>();
            for (int c = 0; c < hrow.getLastCellNum(); c++) {
                String name = getString(hrow.getCell(c));
                if (name == null || name.isBlank()) name = "COL_" + (c + 1);
                headers.add(name.trim());
            }

            // rows
            List<List<String>> rows = new ArrayList<>();
            for (int r = sh.getFirstRowNum() + 1; r <= sh.getLastRowNum(); r++) {
                Row row = sh.getRow(r);
                if (row == null) continue;
                List<String> vals = new ArrayList<>(headers.size());
                boolean any = false;
                for (int c = 0; c < headers.size(); c++) {
                    String v = getString(row.getCell(c));
                    if (v != null && !v.isBlank()) any = true;
                    vals.add(safe(v));
                }
                if (any) rows.add(vals);
            }
            return new ExcelData(headers, rows);
        }
    }

    private static String getString(Cell cell) {
        if (cell == null) return null;
        return switch (cell.getCellType()) {
            case STRING -> cell.getStringCellValue();
            case NUMERIC -> {
                double d = cell.getNumericCellValue();
                long l = (long) d;
                yield (d == l) ? Long.toString(l) : Double.toString(d);
            }
            case BOOLEAN -> Boolean.toString(cell.getBooleanCellValue());
            case FORMULA -> {
                try { yield cell.getStringCellValue(); }
                catch (Exception e) { yield Double.toString(cell.getNumericCellValue()); }
            }
            default -> null;
        };
    }

    /* ===================== SQL STAGE ===================== */

    private static void createStageTable(Connection con, String stage, List<String> headers) throws SQLException {
        String cols = headers.stream()
                .map(ExcelVsSqlQueryCompare_DiffOnly::sqlCol)
                .map(c -> c + " NVARCHAR(4000) NULL")
                .collect(Collectors.joining(","));
        String sql = "CREATE TABLE " + stage + " (" + cols + ")";
        try (Statement st = con.createStatement()) { st.execute(sql); }
    }

    private static void insertStage(Connection con, String stage, List<String> headers, List<List<String>> rows) throws SQLException {
        String placeholders = headers.stream().map(h -> "?").collect(Collectors.joining(","));
        String colList = headers.stream().map(ExcelVsSqlQueryCompare_DiffOnly::sqlCol).collect(Collectors.joining(","));
        String sql = "INSERT INTO " + stage + " (" + colList + ") VALUES (" + placeholders + ")";
        try (PreparedStatement ps = con.prepareStatement(sql)) {
            int count = 0;
            for (List<String> r : rows) {
                for (int i = 0; i < headers.size(); i++) ps.setString(i + 1, r.get(i));
                ps.addBatch();
                if (++count % BATCH == 0) ps.executeBatch();
            }
            ps.executeBatch();
        }
    }

    /* ===================== EXISTENCE CHECK ===================== */

    private static List<Map<String,String>> findMissing(Connection con, String stage, List<String> headers) throws SQLException {
        Set<String> joinCols = resolveJoinCols(headers);

        String on = joinCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '') = ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" AND "));

        String firstJoin = joinCols.iterator().next();

        String selectCols = headers.stream()
                .map(h -> "s." + sqlCol(h) + " AS " + sqlCol(h))
                .collect(Collectors.joining(", "));

        String sql = """
            SELECT %s
            FROM %s s
            LEFT JOIN (
                %s
            ) t ON %s
            WHERE t.%s IS NULL
            """.formatted(selectCols, stage, TARGET_SOURCE_SQL, on, sqlCol(firstJoin));

        List<Map<String,String>> out = new ArrayList<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) {
                Map<String,String> row = new LinkedHashMap<>();
                for (String h : headers) row.put(h, rs.getString(h));
                out.add(row);
            }
        }
        return out;
    }

    /* ===================== MISMATCH CHECK (compact) ===================== */

    private static class MismatchRow {
        Map<String,String> excelValues = new LinkedHashMap<>(); // s.*
        String differences; // comma-separated column names that differ
    }

    private static List<MismatchRow> findMismatches(Connection con, String stage, List<String> headers) throws SQLException {
        Set<String> joinCols = resolveJoinCols(headers);
        List<String> compareCols = headers.stream()
                .filter(h -> joinCols.stream().noneMatch(k -> k.equalsIgnoreCase(h)))
                .collect(Collectors.toList());

        if (compareCols.isEmpty()) {
            // Joining on all columns -> mismatches cannot exist by definition.
            return List.of();
        }

        String on = joinCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '') = ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" AND "));

        // any difference across non-key columns
        String anyDiff = compareCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '') <> ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" OR "));

        // Select Excel (stage) values and, for each compare col, a 0/1 flag if it differs
        String stageSelect = headers.stream()
                .map(h -> "s." + sqlCol(h) + " AS " + bracket("s_" + h))
                .collect(Collectors.joining(", "));

        String diffFlags = compareCols.stream()
                .map(h -> "CASE WHEN ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '') " +
                           "<> ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '') THEN 1 ELSE 0 END AS " + bracket("d_" + h))
                .collect(Collectors.joining(", "));

        String sql = """
            SELECT %s, %s
            FROM %s s
            INNER JOIN (
                %s
            ) t ON %s
            WHERE %s
            """.formatted(stageSelect, diffFlags, stage, TARGET_SOURCE_SQL, on, anyDiff);

        List<MismatchRow> out = new ArrayList<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) {
                MismatchRow mr = new MismatchRow();
                // collect Excel values
                for (String h : headers) {
                    mr.excelValues.put(h, rs.getString("s_" + h));
                }
                // build Differences list
                List<String> diffs = new ArrayList<>();
                for (String h : compareCols) {
                    int flag = rs.getInt("d_" + h);
                    if (flag == 1) diffs.add(h);
                }
                mr.differences = String.join(", ", diffs);
                out.add(mr);
            }
        }
        return out;
    }

    /* ===================== OUTPUT ===================== */

    private static void writeOutput(List<String> headers,
                                    List<Map<String,String>> missing,
                                    List<MismatchRow> mismatches,
                                    String outPath) throws IOException {

        try (Workbook wb = new XSSFWorkbook()) {
            // Summary
            Sheet sum = wb.createSheet("Summary");
            Row h = sum.createRow(0);
            h.createCell(0).setCellValue("Metric"); h.createCell(1).setCellValue("Count");
            Row r1 = sum.createRow(1);
            r1.createCell(0).setCellValue("MissingInDB");
            r1.createCell(1).setCellValue(missing.size());
            Row r2 = sum.createRow(2);
            r2.createCell(0).setCellValue("Mismatches");
            r2.createCell(1).setCellValue(mismatches.size());
            sum.autoSizeColumn(0); sum.autoSizeColumn(1);

            // MissingInDB
            Sheet miss = wb.createSheet("MissingInDB");
            Row mh = miss.createRow(0);
            for (int c = 0; c < headers.size(); c++) mh.createCell(c).setCellValue(headers.get(c));
            int r = 1;
            for (Map<String,String> row : missing) {
                Row x = miss.createRow(r++);
                int c = 0;
                for (String hname : headers) x.createCell(c++).setCellValue(safe(row.get(hname)));
            }
            for (int c = 0; c < headers.size(); c++) miss.autoSizeColumn(c);

            // Mismatches (Excel columns + trailing "Differences")
            Sheet diff = wb.createSheet("Mismatches");
            Row dh = diff.createRow(0);
            int c = 0;
            for (String hname : headers) dh.createCell(c++).setCellValue(hname);
            dh.createCell(c).setCellValue("Differences"); // last column

            int rr = 1;
            for (MismatchRow mr : mismatches) {
                Row row = diff.createRow(rr++);
                int cc = 0;
                for (String hname : headers) row.createCell(cc++).setCellValue(safe(mr.excelValues.get(hname)));
                row.createCell(cc).setCellValue(mr.differences);
            }
            for (int i = 0; i < headers.size() + 1; i++) diff.autoSizeColumn(i);

            // Save
            try (OutputStream os = new FileOutputStream(outPath)) { wb.write(os); }
        }
    }

    /* ===================== HELPERS ===================== */

    private static Set<String> resolveJoinCols(List<String> headers) {
        return KEY_COLUMNS.isEmpty()
                ? new LinkedHashSet<>(headers) // all columns as keys -> no mismatches possible
                : headers.stream()
                         .filter(h -> KEY_COLUMNS.stream().anyMatch(k -> k.equalsIgnoreCase(h)))
                         .collect(Collectors.toCollection(LinkedHashSet::new));
    }

    private static String sqlCol(String header) { return "[" + header.replace("]", "]]") + "]"; }
    private static String bracket(String alias)  { return "[" + alias.replace("]", "]]") + "]"; }
    private static String safe(String s) { return s == null ? "" : s; }
}

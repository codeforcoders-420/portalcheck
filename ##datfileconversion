import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.*;
import java.nio.file.Path;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Compares an Excel sheet against a SQL Server SELECT query.
 * Produces "MissingInDB" = rows in Excel not returned by the query.
 *
 * How to use:
 *  1) Set EXCEL_PATH, SHEET_NAME.
 *  2) Paste your SELECT into TARGET_SOURCE_SQL and alias columns to match Excel headers.
 *  3) Set JDBC_URL (pick one of the provided URLs).
 *  4) (Optional) set KEY_COLUMNS to match on a subset; leave empty to match on ALL columns.
 *  5) Run. Output file: C:/temp/ExcelVsDB_Check.xlsx
 */
public class ExcelVsSqlQueryCompare {

    /* ===================== USER SETTINGS ===================== */

    // 1) Excel input
    private static final Path EXCEL_PATH = Path.of("C:/temp/input.xlsx");
    private static final String SHEET_NAME = "Source M"; // change as needed

    // 2) Your SQL SELECT (must be a single SELECT) â€” alias columns to match Excel headers 1:1.
    // Example shown; replace with your actual query.
    private static final String TARGET_SOURCE_SQL = """
        SELECT
            [Year Applied],
            [NBU start date],
            [NBU term date],
            [RVS ID],
            [Procedure Code],
            [Modifier],
            [Status Indicator],
            [Work RVU (4.2)],
            [Non-facility Practice Expense RVS (4.2)],
            [Facility Practice Expense (4.2)],
            [Malpractice RVU (4.2)],
            [Non-facility Total RVU (4.2)],
            [Facility Total RVU (4.2)],
            [Update Indicator],
            [Global Period]
        FROM dbo.YourTargetTable
        WHERE SomeFilter = 1
        """;

    // 3) SQL Server connection (choose ONE URL; comment out the other)
    // (A) Native Integrated Security (requires sqljdbc_auth.dll on PATH; matches your JDK arch)
    private static final String JDBC_URL =
        "jdbc:sqlserver://YOUR_SERVER;databaseName=YOUR_DB;" +
        "encrypt=true;trustServerCertificate=true;" +
        "integratedSecurity=true;authenticationScheme=NativeAuthentication";

    // (B) Or Azure AD / domain-joined Integrated (no dll):
    // private static final String JDBC_URL =
    //     "jdbc:sqlserver://YOUR_SERVER;databaseName=YOUR_DB;" +
    //     "encrypt=true;trustServerCertificate=true;authentication=ActiveDirectoryIntegrated";

    // 4) Matching behavior
    // If empty => compare on ALL columns; otherwise only on these (case-insensitive, must exist in Excel headers & your SQL).
    private static final Set<String> KEY_COLUMNS = Set.of(); // e.g., Set.of("Procedure Code","Modifier","Status Indicator")

    // 5) Output
    private static final String OUTPUT_XLSX = "C:/temp/ExcelVsDB_Check.xlsx";

    // 6) Insert batch size
    private static final int BATCH = 2000;

    /* ===================== MAIN ===================== */

    public static void main(String[] args) throws Exception {
        ExcelData excel = readExcel(EXCEL_PATH, SHEET_NAME);
        if (excel.headers.isEmpty()) {
            System.err.println("No headers found in Excel. Aborting.");
            return;
        }
        System.out.println("Loaded Excel: " + excel.rows.size() + " rows, " + excel.headers.size() + " columns");

        try (Connection con = DriverManager.getConnection(JDBC_URL)) {
            con.setAutoCommit(false);

            String stage = "#stage_" + UUID.randomUUID().toString().replace("-", "");
            createStageTable(con, stage, excel.headers);
            insertStage(con, stage, excel.headers, excel.rows);
            con.commit();

            List<Map<String,String>> missing = findMissing(con, stage, excel.headers);

            writeOutput(excel.headers, missing, OUTPUT_XLSX);

            System.out.println("Missing rows (present in Excel but not in DB result): " + missing.size());
            System.out.println("Result written to: " + OUTPUT_XLSX);
        }
    }

    /* ===================== EXCEL ===================== */

    private record ExcelData(List<String> headers, List<List<String>> rows) {}

    private static ExcelData readExcel(Path path, String sheetName) throws IOException {
        try (InputStream is = new FileInputStream(path.toFile());
             Workbook wb = new XSSFWorkbook(is)) {

            Sheet sh = (sheetName == null || sheetName.isBlank()) ? wb.getSheetAt(0) : wb.getSheet(sheetName);
            if (sh == null) throw new IllegalArgumentException("Sheet not found: " + sheetName);

            // headers
            Row hrow = sh.getRow(sh.getFirstRowNum());
            if (hrow == null) throw new IllegalStateException("Header row not found.");
            List<String> headers = new ArrayList<>();
            for (int c = 0; c < hrow.getLastCellNum(); c++) {
                String name = getString(hrow.getCell(c));
                if (name == null || name.isBlank()) name = "COL_" + (c + 1);
                headers.add(name.trim());
            }

            // rows
            List<List<String>> rows = new ArrayList<>();
            for (int r = sh.getFirstRowNum() + 1; r <= sh.getLastRowNum(); r++) {
                Row row = sh.getRow(r);
                if (row == null) continue;
                List<String> vals = new ArrayList<>(headers.size());
                boolean any = false;
                for (int c = 0; c < headers.size(); c++) {
                    String v = getString(row.getCell(c));
                    if (v != null && !v.isBlank()) any = true;
                    vals.add(safe(v));
                }
                if (any) rows.add(vals);
            }
            return new ExcelData(headers, rows);
        }
    }

    private static String getString(Cell cell) {
        if (cell == null) return null;
        return switch (cell.getCellType()) {
            case STRING -> cell.getStringCellValue();
            case NUMERIC -> {
                double d = cell.getNumericCellValue();
                long l = (long) d;
                yield (d == l) ? Long.toString(l) : Double.toString(d);
            }
            case BOOLEAN -> Boolean.toString(cell.getBooleanCellValue());
            case FORMULA -> {
                try { yield cell.getStringCellValue(); }
                catch (Exception e) { yield Double.toString(cell.getNumericCellValue()); }
            }
            default -> null;
        };
    }

    /* ===================== SQL: STAGE & INSERT ===================== */

    private static void createStageTable(Connection con, String stage, List<String> headers) throws SQLException {
        String cols = headers.stream()
                .map(ExcelVsSqlQueryCompare::sqlCol)
                .map(c -> c + " NVARCHAR(4000) NULL")
                .collect(Collectors.joining(","));
        String sql = "CREATE TABLE " + stage + " (" + cols + ")";
        try (Statement st = con.createStatement()) {
            st.execute(sql);
        }
    }

    private static void insertStage(Connection con, String stage, List<String> headers, List<List<String>> rows) throws SQLException {
        String placeholders = headers.stream().map(h -> "?").collect(Collectors.joining(","));
        String colList = headers.stream().map(ExcelVsSqlQueryCompare::sqlCol).collect(Collectors.joining(","));
        String sql = "INSERT INTO " + stage + " (" + colList + ") VALUES (" + placeholders + ")";
        try (PreparedStatement ps = con.prepareStatement(sql)) {
            int count = 0;
            for (List<String> r : rows) {
                for (int i = 0; i < headers.size(); i++) {
                    ps.setString(i + 1, r.get(i));
                }
                ps.addBatch();
                if (++count % BATCH == 0) ps.executeBatch();
            }
            ps.executeBatch();
        }
    }

    /* ===================== COMPARISON ===================== */

    private static List<Map<String,String>> findMissing(Connection con, String stage, List<String> headers) throws SQLException {
        // Determine the join columns: either all headers or the subset specified in KEY_COLUMNS
        Set<String> joinCols = KEY_COLUMNS.isEmpty()
                ? new LinkedHashSet<>(headers)
                : headers.stream()
                         .filter(h -> KEY_COLUMNS.stream().anyMatch(k -> k.equalsIgnoreCase(h)))
                         .collect(Collectors.toCollection(LinkedHashSet::new));
        if (joinCols.isEmpty())
            throw new IllegalStateException("No columns to join on. Check KEY_COLUMNS vs Excel headers.");

        // ON clause: compare trimmed strings with NULL-safe equality
        String on = joinCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '') = ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" AND "));

        // We need one column to check NULL on the right side; pick the first join column
        String firstJoinCol = joinCols.iterator().next();

        String selectCols = headers.stream()
                .map(h -> "s." + sqlCol(h) + " AS " + sqlCol(h))
                .collect(Collectors.joining(", "));

        // Join stage (Excel) to YOUR SELECT as a derived table "t"
        String sql = """
            SELECT %s
            FROM %s s
            LEFT JOIN (
                %s
            ) t ON %s
            WHERE t.%s IS NULL
            """.formatted(selectCols, stage, TARGET_SOURCE_SQL, on, sqlCol(firstJoinCol));

        List<Map<String,String>> out = new ArrayList<>();
        try (Statement st = con.createStatement();
             ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) {
                Map<String,String> row = new LinkedHashMap<>();
                for (String h : headers) {
                    row.put(h, rs.getString(h));
                }
                out.add(row);
            }
        }
        return out;
    }

    /* ===================== OUTPUT ===================== */

    private static void writeOutput(List<String> headers, List<Map<String,String>> missing, String outPath) throws IOException {
        try (Workbook wb = new XSSFWorkbook()) {

            // Summary
            Sheet sum = wb.createSheet("Summary");
            Row r0 = sum.createRow(0);
            r0.createCell(0).setCellValue("Metric");
            r0.createCell(1).setCellValue("Count");
            Row r1 = sum.createRow(1);
            r1.createCell(0).setCellValue("Excel rows");
            r1.createCell(1).setCellValue(missing.size() + " missing (see tab)");
            sum.autoSizeColumn(0); sum.autoSizeColumn(1);

            // MissingInDB
            Sheet miss = wb.createSheet("MissingInDB");
            Row head = miss.createRow(0);
            for (int c = 0; c < headers.size(); c++) head.createCell(c).setCellValue(headers.get(c));

            int rr = 1;
            for (Map<String,String> row : missing) {
                Row x = miss.createRow(rr++);
                int c = 0;
                for (String h : headers) x.createCell(c++).setCellValue(safe(row.get(h)));
            }
            for (int c = 0; c < headers.size(); c++) miss.autoSizeColumn(c);

            try (OutputStream os = new FileOutputStream(outPath)) {
                wb.write(os);
            }
        }
    }

    /* ===================== HELPERS ===================== */

    private static String sqlCol(String header) {
        // safe bracketed name, supports spaces and special chars
        return "[" + header.replace("]", "]]") + "]";
    }
    private static String safe(String s) { return s == null ? "" : s; }
}

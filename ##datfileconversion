import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.*;
import java.nio.file.Path;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Excel ↔ SQL Server bidirectional comparison.
 *
 * Outputs an Excel report with:
 *  - Summary
 *  - MissingInDB        : Excel rows not found in DB (join on KEY_COLUMNS)
 *  - MissingInExcel     : DB rows not found in Excel (reverse)
 *  - Mismatches_ExcelToDB : Keys match, but values differ (row base = Excel); trailing "Differences" column
 *  - Mismatches_DBToExcel : Keys match, but values differ (row base = DB);    trailing "Differences" column
 *
 * Requirements:
 *  - TARGET_SOURCE_SQL must be a single SELECT.
 *  - Columns in TARGET_SOURCE_SQL must exactly match the Excel headers (alias in SQL as needed).
 *  - Windows auth supported: Native (sqljdbc_auth.dll) or AAD Integrated.
 */
public class ExcelVsSqlQueryCompare_FullBidirectional {

    /* ===================== USER SETTINGS ===================== */

    // Excel input
    private static final Path EXCEL_PATH = Path.of("C:/temp/input.xlsx");
    private static final String SHEET_NAME = "Source M"; // change if needed

    // Your SQL SELECT (alias columns to match Excel headers 1:1)
    private static final String TARGET_SOURCE_SQL = """
        SELECT
            [Year Applied],
            [NBU start date],
            [NBU term date],
            [RVS ID],
            [Procedure Code],
            [Modifier],
            [Status Indicator],
            [Work RVU (4.2)],
            [Non-facility Practice Expense RVS (4.2)],
            [Facility Practice Expense (4.2)],
            [Malpractice RVU (4.2)],
            [Non-facility Total RVU (4.2)],
            [Facility Total RVU (4.2)],
            [Update Indicator],
            [Global Period]
        FROM dbo.YourTargetTable
        WHERE SomeFilter = 1
        """;

    // SQL Server connection (choose ONE; comment out the other)
    // (A) Native Integrated Security (requires sqljdbc_auth.dll on PATH; arch must match JVM)
    private static final String JDBC_URL =
        "jdbc:sqlserver://YOUR_SERVER;databaseName=YOUR_DB;" +
        "encrypt=true;trustServerCertificate=true;" +
        "integratedSecurity=true;authenticationScheme=NativeAuthentication";

    // (B) Azure AD / domain-joined Integrated (no DLL)
    // private static final String JDBC_URL =
    //     "jdbc:sqlserver://YOUR_SERVER;databaseName=YOUR_DB;" +
    //     "encrypt=true;trustServerCertificate=true;authentication=ActiveDirectoryIntegrated";

    // Keys that uniquely identify a row for matching Excel↔DB
    private static final Set<String> KEY_COLUMNS = Set.of("RVS ID", "Procedure Code", "Modifier");

    // Output location
    private static final String OUTPUT_XLSX = "C:/temp/ExcelVsDB_Check.xlsx";

    // Insert batch size
    private static final int BATCH = 2000;

    /* ===================== MAIN ===================== */

    public static void main(String[] args) throws Exception {
        ExcelData excel = readExcel(EXCEL_PATH, SHEET_NAME);
        if (excel.headers.isEmpty()) {
            System.err.println("No headers found in Excel. Aborting.");
            return;
        }
        System.out.printf("Loaded Excel: %,d rows, %,d columns%n", excel.rows.size(), excel.headers.size());

        try (Connection con = DriverManager.getConnection(JDBC_URL)) {
            con.setAutoCommit(false);

            String stage = "#stage_" + UUID.randomUUID().toString().replace("-", "");
            createStageTable(con, stage, excel.headers);
            insertStage(con, stage, excel.headers, excel.rows);
            con.commit();

            List<Map<String,String>> missingInDb        = findMissingInDb(con, stage, excel.headers);
            List<Map<String,String>> missingInExcel     = findMissingInExcel(con, stage, excel.headers);

            List<MismatchRow> mismExcelToDb = findMismatchesExcelToDB(con, stage, excel.headers);
            List<MismatchRow> mismDbToExcel = findMismatchesDBToExcel(con, stage, excel.headers);

            writeOutput(excel.headers, missingInDb, missingInExcel, mismExcelToDb, mismDbToExcel, OUTPUT_XLSX);

            System.out.println("MissingInDB:        " + missingInDb.size());
            System.out.println("MissingInExcel:     " + missingInExcel.size());
            System.out.println("Mismatches_ExcelToDB: " + mismExcelToDb.size());
            System.out.println("Mismatches_DBToExcel: " + mismDbToExcel.size());
            System.out.println("Report: " + OUTPUT_XLSX);
        }
    }

    /* ===================== EXCEL READ ===================== */

    private record ExcelData(List<String> headers, List<List<String>> rows) {}

    private static ExcelData readExcel(Path path, String sheetName) throws IOException {
        try (InputStream is = new FileInputStream(path.toFile());
             Workbook wb = new XSSFWorkbook(is)) {

            Sheet sh = (sheetName == null || sheetName.isBlank()) ? wb.getSheetAt(0) : wb.getSheet(sheetName);
            if (sh == null) throw new IllegalArgumentException("Sheet not found: " + sheetName);

            // headers
            Row hrow = sh.getRow(sh.getFirstRowNum());
            if (hrow == null) throw new IllegalStateException("Header row not found.");
            List<String> headers = new ArrayList<>();
            for (int c = 0; c < hrow.getLastCellNum(); c++) {
                String name = getString(hrow.getCell(c));
                if (name == null || name.isBlank()) name = "COL_" + (c + 1);
                headers.add(name.trim());
            }

            // rows
            List<List<String>> rows = new ArrayList<>();
            for (int r = sh.getFirstRowNum() + 1; r <= sh.getLastRowNum(); r++) {
                Row row = sh.getRow(r);
                if (row == null) continue;
                List<String> vals = new ArrayList<>(headers.size());
                boolean any = false;
                for (int c = 0; c < headers.size(); c++) {
                    String v = getString(row.getCell(c));
                    if (v != null && !v.isBlank()) any = true;
                    vals.add(safe(v));
                }
                if (any) rows.add(vals);
            }
            return new ExcelData(headers, rows);
        }
    }

    private static String getString(Cell cell) {
        if (cell == null) return null;
        return switch (cell.getCellType()) {
            case STRING -> cell.getStringCellValue();
            case NUMERIC -> {
                double d = cell.getNumericCellValue();
                long l = (long) d;
                yield (d == l) ? Long.toString(l) : Double.toString(d);
            }
            case BOOLEAN -> Boolean.toString(cell.getBooleanCellValue());
            case FORMULA -> {
                try { yield cell.getStringCellValue(); }
                catch (Exception e) { yield Double.toString(cell.getNumericCellValue()); }
            }
            default -> null;
        };
    }

    /* ===================== SQL STAGE ===================== */

    private static void createStageTable(Connection con, String stage, List<String> headers) throws SQLException {
        String cols = headers.stream()
                .map(ExcelVsSqlQueryCompare_FullBidirectional::sqlCol)
                .map(c -> c + " NVARCHAR(4000) NULL")
                .collect(Collectors.joining(","));
        String sql = "CREATE TABLE " + stage + " (" + cols + ")";
        try (Statement st = con.createStatement()) { st.execute(sql); }
    }

    private static void insertStage(Connection con, String stage, List<String> headers, List<List<String>> rows) throws SQLException {
        String placeholders = headers.stream().map(h -> "?").collect(Collectors.joining(","));
        String colList = headers.stream().map(ExcelVsSqlQueryCompare_FullBidirectional::sqlCol).collect(Collectors.joining(","));
        String sql = "INSERT INTO " + stage + " (" + colList + ") VALUES (" + placeholders + ")";
        try (PreparedStatement ps = con.prepareStatement(sql)) {
            int count = 0;
            for (List<String> r : rows) {
                for (int i = 0; i < headers.size(); i++) ps.setString(i + 1, r.get(i));
                ps.addBatch();
                if (++count % BATCH == 0) ps.executeBatch();
            }
            ps.executeBatch();
        }
    }

    /* ===================== EXISTENCE: Excel -> DB ===================== */

    private static List<Map<String,String>> findMissingInDb(Connection con, String stage, List<String> headers) throws SQLException {
        Set<String> joinCols = resolveJoinCols(headers);

        String on = joinCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '') = ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" AND "));

        String firstJoin = joinCols.iterator().next();

        String selectCols = headers.stream()
                .map(h -> "s." + sqlCol(h) + " AS " + sqlCol(h))
                .collect(Collectors.joining(", "));

        String sql = """
            SELECT %s
            FROM %s s
            LEFT JOIN (
                %s
            ) t ON %s
            WHERE t.%s IS NULL
            """.formatted(selectCols, stage, TARGET_SOURCE_SQL, on, sqlCol(firstJoin));

        List<Map<String,String>> out = new ArrayList<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) {
                Map<String,String> row = new LinkedHashMap<>();
                for (String h : headers) row.put(h, rs.getString(h));
                out.add(row);
            }
        }
        return out;
    }

    /* ===================== EXISTENCE (REVERSE): DB -> Excel ===================== */

    private static List<Map<String,String>> findMissingInExcel(Connection con, String stage, List<String> headers) throws SQLException {
        Set<String> joinCols = resolveJoinCols(headers);

        String on = joinCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '') = ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" AND "));

        String firstJoin = joinCols.iterator().next();

        String selectColsDb = headers.stream()
                .map(h -> "t." + sqlCol(h) + " AS " + sqlCol(h))
                .collect(Collectors.joining(", "));

        String sql = """
            SELECT %s
            FROM (
                %s
            ) t
            LEFT JOIN %s s ON %s
            WHERE s.%s IS NULL
            """.formatted(selectColsDb, TARGET_SOURCE_SQL, stage, on, sqlCol(firstJoin));

        List<Map<String,String>> out = new ArrayList<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) {
                Map<String,String> row = new LinkedHashMap<>();
                for (String h : headers) row.put(h, rs.getString(h));
                out.add(row);
            }
        }
        return out;
    }

    /* ===================== MISMATCHES: Excel -> DB (row base = Excel) ===================== */

    private static class MismatchRow {
        Map<String,String> baseValues = new LinkedHashMap<>(); // Excel or DB values, depending on the method
        String differences; // e.g., "Allowed: Excel=25.00, DB=26.00; Status Indicator: Excel=A, DB=R"
    }

    private static List<MismatchRow> findMismatchesExcelToDB(Connection con, String stage, List<String> headers) throws SQLException {
        Set<String> joinCols = resolveJoinCols(headers);
        List<String> compareCols = nonKeyColumns(headers, joinCols);
        if (compareCols.isEmpty()) return List.of();

        String on = joinCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '') = ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" AND "));

        String stageSelect = headers.stream()
                .map(h -> "s." + sqlCol(h) + " AS " + bracket("s_" + h))
                .collect(Collectors.joining(", "));
        String dbSelect = compareCols.stream()
                .map(h -> "t." + sqlCol(h) + " AS " + bracket("t_" + h))
                .collect(Collectors.joining(", "));

        String anyDiff = compareCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '') <> ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" OR "));

        String sql = """
            SELECT %s, %s
            FROM %s s
            INNER JOIN (
                %s
            ) t ON %s
            WHERE %s
            """.formatted(stageSelect, dbSelect, stage, TARGET_SOURCE_SQL, on, anyDiff);

        List<MismatchRow> out = new ArrayList<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) {
                MismatchRow mr = new MismatchRow();

                // Base row = Excel values
                for (String h : headers) {
                    mr.baseValues.put(h, rs.getString("s_" + h));
                }

                // Build detailed Differences text
                List<String> parts = new ArrayList<>();
                for (String h : compareCols) {
                    String sv = norm(rs.getString("s_" + h));
                    String tv = norm(rs.getString("t_" + h));
                    if (!Objects.equals(sv, tv)) {
                        parts.add(h + ": Excel=" + safeForDiff(sv) + ", DB=" + safeForDiff(tv));
                    }
                }
                mr.differences = String.join("; ", parts);
                out.add(mr);
            }
        }
        return out;
    }

    /* ===================== MISMATCHES: DB -> Excel (row base = DB) ===================== */

    private static List<MismatchRow> findMismatchesDBToExcel(Connection con, String stage, List<String> headers) throws SQLException {
        Set<String> joinCols = resolveJoinCols(headers);
        List<String> compareCols = nonKeyColumns(headers, joinCols);
        if (compareCols.isEmpty()) return List.of();

        String on = joinCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '') = ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" AND "));

        String dbSelectAll = headers.stream()
                .map(h -> "t." + sqlCol(h) + " AS " + bracket("t_" + h))
                .collect(Collectors.joining(", "));
        String stageSelectCmp = compareCols.stream()
                .map(h -> "s." + sqlCol(h) + " AS " + bracket("s_" + h))
                .collect(Collectors.joining(", "));

        String anyDiff = compareCols.stream()
                .map(h -> "ISNULL(LTRIM(RTRIM(s." + sqlCol(h) + ")), '') <> ISNULL(LTRIM(RTRIM(t." + sqlCol(h) + ")), '')")
                .collect(Collectors.joining(" OR "));

        String sql = """
            SELECT %s, %s
            FROM (
                %s
            ) t
            INNER JOIN %s s ON %s
            WHERE %s
            """.formatted(dbSelectAll, stageSelectCmp, TARGET_SOURCE_SQL, stage, on, anyDiff);

        List<MismatchRow> out = new ArrayList<>();
        try (Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql)) {
            while (rs.next()) {
                MismatchRow mr = new MismatchRow();

                // Base row = DB values
                for (String h : headers) {
                    mr.baseValues.put(h, rs.getString("t_" + h));
                }

                // Build detailed Differences text (still "Excel=..., DB=...")
                List<String> parts = new ArrayList<>();
                for (String h : compareCols) {
                    String tv = norm(rs.getString("t_" + h));
                    String sv = norm(rs.getString("s_" + h));
                    if (!Objects.equals(sv, tv)) {
                        parts.add(h + ": Excel=" + safeForDiff(sv) + ", DB=" + safeForDiff(tv));
                    }
                }
                mr.differences = String.join("; ", parts);
                out.add(mr);
            }
        }
        return out;
    }

    /* ===================== OUTPUT ===================== */

    private static void writeOutput(List<String> headers,
                                    List<Map<String,String>> missingInDb,
                                    List<Map<String,String>> missingInExcel,
                                    List<MismatchRow> mismExcelToDb,
                                    List<MismatchRow> mismDbToExcel,
                                    String outPath) throws IOException {

        try (Workbook wb = new XSSFWorkbook()) {
            // Summary
            Sheet sum = wb.createSheet("Summary");
            Row h = sum.createRow(0);
            h.createCell(0).setCellValue("Metric"); h.createCell(1).setCellValue("Count");
            Row r1 = sum.createRow(1); r1.createCell(0).setCellValue("MissingInDB");           r1.createCell(1).setCellValue(missingInDb.size());
            Row r2 = sum.createRow(2); r2.createCell(0).setCellValue("MissingInExcel");        r2.createCell(1).setCellValue(missingInExcel.size());
            Row r3 = sum.createRow(3); r3.createCell(0).setCellValue("Mismatches_ExcelToDB");  r3.createCell(1).setCellValue(mismExcelToDb.size());
            Row r4 = sum.createRow(4); r4.createCell(0).setCellValue("Mismatches_DBToExcel");  r4.createCell(1).setCellValue(mismDbToExcel.size());
            sum.autoSizeColumn(0); sum.autoSizeColumn(1);

            // MissingInDB (Excel -> DB)
            writeSimpleSheet(wb, "MissingInDB", headers, missingInDb);

            // MissingInExcel (DB -> Excel)
            writeSimpleSheet(wb, "MissingInExcel", headers, missingInExcel);

            // Mismatches_ExcelToDB: Excel columns + trailing Differences
            writeMismatchSheet(wb, "Mismatches_ExcelToDB", headers, mismExcelToDb);

            // Mismatches_DBToExcel: DB columns + trailing Differences
            writeMismatchSheet(wb, "Mismatches_DBToExcel", headers, mismDbToExcel);

            try (OutputStream os = new FileOutputStream(outPath)) { wb.write(os); }
        }
    }

    private static void writeSimpleSheet(Workbook wb, String sheetName, List<String> headers, List<Map<String,String>> rows) {
        Sheet s = wb.createSheet(sheetName);
        Row head = s.createRow(0);
        for (int c = 0; c < headers.size(); c++) head.createCell(c).setCellValue(headers.get(c));
        int r = 1;
        for (Map<String,String> row : rows) {
            Row x = s.createRow(r++);
            int c = 0;
            for (String hname : headers) x.createCell(c++).setCellValue(safe(row.get(hname)));
        }
        for (int c = 0; c < headers.size(); c++) s.autoSizeColumn(c);
    }

    private static void writeMismatchSheet(Workbook wb, String sheetName, List<String> headers, List<MismatchRow> mismatchRows) {
        Sheet s = wb.createSheet(sheetName);
        Row head = s.createRow(0);
        int c = 0;
        for (String hname : headers) head.createCell(c++).setCellValue(hname);
        head.createCell(c).setCellValue("Differences");

        int r = 1;
        for (MismatchRow mr : mismatchRows) {
            Row x = s.createRow(r++);
            int cc = 0;
            for (String hname : headers) x.createCell(cc++).setCellValue(safe(mr.baseValues.get(hname)));
            x.createCell(cc).setCellValue(mr.differences);
        }
        for (int i = 0; i < headers.size() + 1; i++) s.autoSizeColumn(i);
    }

    /* ===================== HELPERS ===================== */

    private static Set<String> resolveJoinCols(List<String> headers) {
        // Keys must exist in headers
        Set<String> joinCols = headers.stream()
                .filter(h -> KEY_COLUMNS.stream().anyMatch(k -> k.equalsIgnoreCase(h)))
                .collect(Collectors.toCollection(LinkedHashSet::new));
        if (joinCols.isEmpty())
            throw new IllegalStateException("KEY_COLUMNS do not match any Excel headers.");
        return joinCols;
    }

    private static List<String> nonKeyColumns(List<String> headers, Set<String> keys) {
        return headers.stream()
                .filter(h -> keys.stream().noneMatch(k -> k.equalsIgnoreCase(h)))
                .collect(Collectors.toList());
    }

    private static String sqlCol(String header) { return "[" + header.replace("]", "]]") + "]"; }
    private static String bracket(String alias)  { return "[" + alias.replace("]", "]]") + "]"; }
    private static String safe(String s) { return s == null ? "" : s; }
    private static String norm(String s) { return s == null ? "" : s.trim(); }
}

#!/usr/bin/env python3
"""
Extract Procedure, Mod, and Rate from a Lab Max Allowable PDF.

Features
- Handles CPT (5 digits), HCPCS (Letter+4 digits), PLA/MAAA (4 digits + trailing letter like 0247U / 0003M)
- Preserves modifiers (26, TC, DEF, POS, QW), including inline suffixes (e.g., 80305QW)
- Accepts rates like 1,234.56, 1234.56, or split as tokens "1234 . 56"
- Keeps rows even if Rate is blank
- Exports one combined Excel + one sheet per page for a specified range (default 12â€“25)

Usage
------
python extract_lab_rates.py --pdf "Lab Max Allowable October 2025  20251001184417.pdf" --start 12 --end 25 --out "output"

Requirements
------------
pip install pdfplumber pandas XlsxWriter
"""

import re
import argparse
from pathlib import Path
import pdfplumber
import pandas as pd


# Patterns
RATE_RE = re.compile(r"^\$?(?:\d{1,3}(?:,\d{3})+|\d+)(?:\.\d{2})$")  # 1,234.56 or 1234.56 (with/without $)
PROC_TOKEN_RE = re.compile(
    r"^(?P<base>(?:\d{5}|[A-Za-z]\d{4}|\d{4}[A-Za-z]))(?P<sfx>[A-Za-z]{1,2})?$"
)  # CPT, HCPCS, PLA/MAAA
MOD_VALUES = {"26", "TC", "DEF", "POS", "QW"}


def group_lines(chars, ytol=2.0):
    """Group characters into visual lines by Y position with a small tolerance."""
    lines = []
    for ch in sorted(chars, key=lambda c: (c.get("top", 0), c.get("x0", 0))):
        y = ch.get("top", 0)
        for line in lines:
            if abs(line["y"] - y) <= ytol:
                line["chars"].append(ch)
                break
        else:
            lines.append({"y": y, "chars": [ch]})
    for line in lines:
        line["chars"].sort(key=lambda c: c.get("x0", 0))
    lines.sort(key=lambda l: l["y"])
    return lines


def line_tokens(chars, xtol=1.6):
    """Join adjacent characters into tokens by X gaps; normalize whitespace."""
    tokens, current, prev_x1 = [], [], None
    for ch in chars:
        x0, x1 = ch.get("x0", 0), ch.get("x1", 0)
        text = ch.get("text", "")
        if prev_x1 is None or x0 - prev_x1 <= xtol:
            current.append(text)
        else:
            tok = "".join(current).strip()
            if tok:
                tokens.append(tok)
            current = [text]
        prev_x1 = x1
    if current:
        tok = "".join(current).strip()
        if tok:
            tokens.append(tok)
    # Normalize NBSP and extra spaces
    return [t.replace("\u00A0", " ").strip() for t in tokens if t.strip()]


def parse_line(tokens):
    """Parse one visual line into zero or more (Procedure, Mod, Rate) tuples."""
    out, i = [], 0
    while i < len(tokens):
        tok = tokens[i]
        m = PROC_TOKEN_RE.match(tok)
        if m:
            proc = m.group("base").upper()
            inline_suffix = (m.group("sfx") or "").upper()
            mod = inline_suffix if inline_suffix in MOD_VALUES else ""

            i += 1
            # explicit modifier token possibly following
            if i < len(tokens) and tokens[i].upper() in MOD_VALUES:
                nxt = tokens[i].upper()
                mod = (mod + ("+" if (mod and nxt != mod) else "") + nxt).strip("+")
                i += 1

            # rate (accept comma or plain; also support split decimals as N . NN)
            rate = ""
            if i < len(tokens) and RATE_RE.match(tokens[i]):
                rate = tokens[i].lstrip("$")
                i += 1
            elif i + 2 < len(tokens) and re.fullmatch(r"\d+", tokens[i]) and tokens[i+1] == "." and re.fullmatch(r"\d{2}", tokens[i+2]):
                rate = f"{tokens[i]}.{tokens[i+2]}"
                i += 3

            out.append((proc, mod, rate))
        else:
            i += 1
    return out


def extract(pdf_path: Path, start_page: int, end_page: int) -> pd.DataFrame:
    """Extract (Page, Procedure, Mod, Rate) for the given page range (inclusive)."""
    records = []
    page_counts = {}

    with pdfplumber.open(str(pdf_path)) as pdf:
        total_pages = len(pdf.pages)
        if start_page < 1 or start_page > total_pages:
            raise ValueError(f"start page {start_page} is out of bounds (1..{total_pages})")
        end_page = min(end_page, total_pages)

        for p in range(start_page, end_page + 1):
            page = pdf.pages[p - 1]
            lines = group_lines(page.chars, ytol=2.0)
            page_rows = []
            for line in lines:
                toks = line_tokens(line["chars"], xtol=1.6)
                # skip header rows of the section tables
                if toks[:3] == ["Procedure", "Mod.", "Rate"] or toks[:2] == ["Procedure", "Rate"]:
                    continue
                page_rows.extend(parse_line(toks))

            page_counts[p] = len(page_rows)
            for proc, mod, rate in page_rows:
                records.append((p, proc, mod, rate))

    df = pd.DataFrame(records, columns=["Page", "Procedure", "Mod", "Rate"])
    print("Counts per page:", page_counts)
    return df


def save_outputs(df: pd.DataFrame, out_dir: Path, label: str):
    out_dir.mkdir(parents=True, exist_ok=True)
    all_path = out_dir / f"{label}_AllCodesRates.xlsx"
    by_page_path = out_dir / f"{label}_ByPage.xlsx"

    # Combined
    df.to_excel(all_path, index=False)

    # One sheet per page
    with pd.ExcelWriter(by_page_path, engine="xlsxwriter") as writer:
        for p in sorted(df["Page"].astype(int).unique()):
            df[df["Page"] == p][["Procedure", "Mod", "Rate"]].to_excel(writer, sheet_name=f"Page{p}", index=False)

    print(f"Saved: {all_path}")
    print(f"Saved: {by_page_path}")


def main():
    ap = argparse.ArgumentParser(description="Extract Procedure/Mod/Rate tables from Lab Max Allowable PDF.")
    ap.add_argument("--pdf", required=True, help="Path to the PDF file.")
    ap.add_argument("--start", type=int, default=12, help="Start page (1-indexed). Default: 12")
    ap.add_argument("--end", type=int, default=25, help="End page (inclusive). Default: 25")
    ap.add_argument("--out", default="out", help="Output folder. Default: ./out")
    ap.add_argument("--label", default="Pages12_25", help="Label prefix for output filenames. Default: Pages12_25")
    args = ap.parse_args()

    pdf_path = Path(args.pdf)
    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF not found: {pdf_path}")

    df = extract(pdf_path, args.start, args.end)
    save_outputs(df, Path(args.out), args.label)


if __name__ == "__main__":
    main()

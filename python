import re
import pdfplumber
import pandas as pd
from pathlib import Path
import tkinter as tk
from tkinter import ttk, filedialog, messagebox

# -----------------------------
# Parsing logic (robust + headerless-friendly)
# -----------------------------

# Valid code patterns:
#  - H#### (e.g., H0031, H2015)
#  - T####, G#### (common HCPCS/CPT prefixes)
#  - #####  (pure 5-digit CPT like 99446)
CODE_PAT = re.compile(r"^(?:H\d{4}|T\d{4}|G\d{4}|\d{5})$")

# Valid modifier patterns:
#  - GT
#  - U + digit(s) or letter(s), e.g., U2, U7, UK, UD, UC...
MOD_PAT = re.compile(r"^(?:GT|U[A-Z0-9]{1,2})$")

RATE_ONLY_PAT = re.compile(r"^\$?(\d+\.\d{2})$")  # matches "26.65" or "$26.65"


def parse_tokens_from_text(text: str, page_number: int):
    """
    Parse one page's text into rows:
      [Code, Mod1, Mod2, Mod3, Mod4, Rate, Page Number]

    Works with or without visible table headers; resilient to left/right split tables.
    """
    tokens = text.split()
    rows = []
    i = 0
    while i < len(tokens):
        tok = tokens[i]

        # Look for a valid code token
        if CODE_PAT.fullmatch(tok):
            code = tok
            i += 1

            # Collect modifiers in order until we hit the rate
            mods = []
            rate = None
            while i < len(tokens):
                tt = tokens[i]

                # Rate cases: "$ 26.65", "$26.65", or "26.65"
                if tt == "$" and i + 1 < len(tokens) and re.fullmatch(r"\d+\.\d{2}", tokens[i + 1]):
                    rate = tokens[i + 1]
                    i += 2
                    break
                m = RATE_ONLY_PAT.match(tt)
                if m:
                    rate = m.group(1)
                    i += 1
                    break

                # Collect modifiers
                if MOD_PAT.fullmatch(tt):
                    mods.append(tt)

                i += 1

            # Normalize to Mod1..Mod4
            mods = (mods + ["", "", "", ""])[:4]

            if rate:
                rows.append([code] + mods + [rate, page_number])
            continue

        i += 1

    return rows


def extract_page(doc, page_index_zero_based: int):
    """
    Extract rows from a single PDF page:
    - Uses extract_text() and the token parser (best for this document layout).
    Returns (rows, raw_text)
    """
    page = doc.pages[page_index_zero_based]
    text = page.extract_text() or ""
    rows = parse_tokens_from_text(text, page_index_zero_based + 1)
    return rows, text


def parse_page_spec(pages_str: str):
    """
    Parse page specs like:
      '21,22,24-26,25-CONTD'  -->  [21, 22, 24, 25, 26]
    The '-CONTD' suffix is accepted for human readability and ignored by the parser.
    """
    pages = set()
    for raw in pages_str.split(","):
        part = raw.strip()
        if not part:
            continue

        # Allow '25-CONTD' or '25-contd'
        if "-CONTD" in part.upper():
            part = part.split("-", 1)[0].strip()

        # Ranges like '24-26'
        if "-" in part and "CONTD" not in part.upper():
            a, b = part.split("-", 1)
            a, b = a.strip(), b.strip()
            if a.isdigit() and b.isdigit():
                start, end = int(a), int(b)
                if start <= end:
                    for p in range(start, end + 1):
                        pages.add(p)
        else:
            if part.isdigit():
                pages.add(int(part))

    return sorted(pages)


# -----------------------------
# GUI
# -----------------------------

class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("DBHDD PDF → Excel Extractor")
        self.geometry("880x560")
        self.resizable(True, True)

        self.pdf_path_var = tk.StringVar()
        self.page_spec_var = tk.StringVar(value="21")  # default
        self.out_path_var = tk.StringVar(value=str(Path.cwd() / "DBHDD_Extract.xlsx"))

        self._build_ui()

    def _build_ui(self):
        pad = {"padx": 10, "pady": 8}

        # Top controls
        top = ttk.Frame(self)
        top.pack(fill="x")

        # PDF
        ttk.Label(top, text="PDF file:").grid(row=0, column=0, sticky="w", **pad)
        ttk.Entry(top, textvariable=self.pdf_path_var, width=80).grid(row=0, column=1, **pad)
        ttk.Button(top, text="Browse…", command=self._pick_pdf).grid(row=0, column=2, **pad)

        # Pages
        ttk.Label(top, text="Pages (e.g., 21,22,24-26,25-CONTD):").grid(row=1, column=0, sticky="w", **pad)
        ttk.Entry(top, textvariable=self.page_spec_var, width=48).grid(row=1, column=1, sticky="w", **pad)

        # Output
        ttk.Label(top, text="Output Excel:").grid(row=2, column=0, sticky="w", **pad)
        ttk.Entry(top, textvariable=self.out_path_var, width=80).grid(row=2, column=1, **pad)
        ttk.Button(top, text="Browse…", command=self._pick_out).grid(row=2, column=2, **pad)

        # Run
        ttk.Button(top, text="Run Extraction", command=self._run).grid(row=3, column=1, sticky="e", **pad)

        # Tabs for Log & Raw Text
        tabs = ttk.Notebook(self)
        tabs.pack(fill="both", expand=True, padx=10, pady=10)

        # Log tab
        log_frame = ttk.Frame(tabs)
        tabs.add(log_frame, text="Log")
        self.log = tk.Text(log_frame, width=120, height=22, wrap="word")
        self.log.pack(fill="both", expand=True)
        log_scroll = ttk.Scrollbar(log_frame, orient="vertical", command=self.log.yview)
        self.log.configure(yscrollcommand=log_scroll.set)
        log_scroll.pack(side="right", fill="y")

        # Raw tab
        raw_frame = ttk.Frame(tabs)
        tabs.add(raw_frame, text="Raw Text")
        self.raw = tk.Text(raw_frame, width=120, height=22, wrap="word")
        self.raw.pack(fill="both", expand=True)
        raw_scroll = ttk.Scrollbar(raw_frame, orient="vertical", command=self.raw.yview)
        self.raw.configure(yscrollcommand=raw_scroll.set)
        raw_scroll.pack(side="right", fill="y")

    def _pick_pdf(self):
        path = filedialog.askopenfilename(
            title="Select PDF",
            filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")]
        )
        if path:
            self.pdf_path_var.set(path)

    def _pick_out(self):
        path = filedialog.asksaveasfilename(
            title="Save Excel As",
            defaultextension=".xlsx",
            filetypes=[("Excel Workbook", "*.xlsx")]
        )
        if path:
            self.out_path_var.set(path)

    def _log(self, msg: str):
        self.log.insert("end", msg + "\n")
        self.log.see("end")
        self.update_idletasks()

    def _raw(self, msg: str):
        self.raw.insert("end", msg + "\n")
        self.raw.see("end")
        self.update_idletasks()

    def _run(self):
        pdf_path = self.pdf_path_var.get().strip()
        out_path = self.out_path_var.get().strip()
        page_spec = self.page_spec_var.get().strip()

        if not pdf_path:
            messagebox.showerror("Missing PDF", "Please select a PDF file.")
            return
        if not page_spec:
            messagebox.showerror("Missing Pages", "Please enter page numbers (e.g., 21,22,24-26).")
            return

        pages = parse_page_spec(page_spec)
        if not pages:
            messagebox.showerror("Invalid Pages", "No valid page numbers found.")
            return

        try:
            self.log.delete("1.0", "end")
            self.raw.delete("1.0", "end")

            self._log(f"Opening PDF: {pdf_path}")
            all_rows = []

            with pdfplumber.open(pdf_path) as pdf:
                max_page = len(pdf.pages)
                self._log(f"PDF has {max_page} pages.")
                for p in pages:
                    if p < 1 or p > max_page:
                        self._log(f"Skipping page {p} (out of range).")
                        continue

                    self._log(f"Extracting page {p} …")
                    rows, raw_text = extract_page(pdf, p - 1)  # 0-based inside
                    self._log(f"  Found rows: {len(rows)}")

                    # Dump raw page text to the Raw Text tab
                    header = f"{'='*20} Page {p} (raw) {'='*20}\n"
                    self._raw(header + (raw_text if raw_text else "[No text returned]") + "\n\n")

                    all_rows.extend(rows)

            # Build DataFrame and save
            df = pd.DataFrame(all_rows, columns=[
                "Code", "Mod1", "Mod2", "Mod3", "Mod4", "Rate", "Page Number"
            ])

            if df.empty:
                self._log("No rows extracted. Check your page selection or the PDF layout.")
            else:
                self._log(f"Total rows extracted: {len(df)}")
                out_path_obj = Path(out_path)
                out_path_obj.parent.mkdir(parents=True, exist_ok=True)
                df.to_excel(out_path_obj, index=False)
                self._log(f"Saved Excel: {out_path_obj}")

            messagebox.showinfo("Done", "Extraction complete.")

        except Exception as e:
            messagebox.showerror("Error", f"Extraction failed:\n{e}")
            self._log(f"Error: {e}")


if __name__ == "__main__":
    app = App()
    app.mainloop()

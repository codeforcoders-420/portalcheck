import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;

import java.io.*;
import java.nio.file.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

public class CsvMonthlyFileMerger {

    record Record(String procCode, String mod, String eff, String term, String method,
                  String allowed, String mod2, String mod3, String mod4, String active) {}

    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("M/d/yyyy");

    private static final List<String> MONTHS = List.of(
            "JAN", "FEB", "MAR", "APR", "MAY", "JUN",
            "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"
    );

    public static void main(String[] args) throws Exception {
        String inputFolder = "src/files/";
        String outputFile = "src/output/Combined.csv";

        // Step 1: Read all valid files from folder
        List<Path> monthlyFiles = Files.list(Paths.get(inputFolder))
                .filter(Files::isRegularFile)
                .filter(p -> p.toString().endsWith(".csv"))
                .filter(p -> containsMonth(p.getFileName().toString()))
                .collect(Collectors.toList());

        if (monthlyFiles.size() < 3) {
            System.out.println("Less than 3 monthly files found. Please check folder.");
            return;
        }

        // Step 2: Load filtered records from each file
        List<Set<Record>> monthlyRecordSets = new ArrayList<>();
        for (Path file : monthlyFiles) {
            monthlyRecordSets.add(readValidRecords(file.toString()));
        }

        // Step 3: Find common records across all months
        Set<Record> commonInAll = new HashSet<>(monthlyRecordSets.get(0));
        for (int i = 1; i < monthlyRecordSets.size(); i++) {
            commonInAll.retainAll(monthlyRecordSets.get(i));
        }

        // Step 4: Group records by procedure+modifiers
        Map<String, List<Record>> grouped = monthlyRecordSets.stream()
                .flatMap(Set::stream)
                .collect(Collectors.groupingBy(rec -> rec.procCode() + "|" + rec.mod() + "|" +
                        rec.mod2() + "|" + rec.mod3() + "|" + rec.mod4()));

        // Step 5: Write output
        try (CSVWriter writer = new CSVWriter(new FileWriter(outputFile))) {
            writer.writeNext(new String[]{"Procedure Code", "Modifier", "Effective", "Termination", "Reimbursement Method",
                    "Allowed", "Modifier2", "Modifier3", "Modifier4", "Active"});

            commonInAll.forEach(r -> writer.writeNext(toRow(r)));

            writer.writeNext(new String[]{"", "", "", "", "", "", "", "", "", ""});
            writer.writeNext(new String[]{"Grouped Records:"});

            for (var entry : grouped.entrySet()) {
                for (Record r : entry.getValue()) {
                    writer.writeNext(toRow(r));
                }
                writer.writeNext(new String[]{"----------------------"});
            }
        }

        System.out.println("Merged CSV written to: " + outputFile);
    }

    private static boolean containsMonth(String fileName) {
        return MONTHS.stream().anyMatch(m -> fileName.toUpperCase().contains(m));
    }

    private static Set<Record> readValidRecords(String filePath) throws Exception {
        Set<Record> records = new HashSet<>();
        try (CSVReader reader = new CSVReader(new FileReader(filePath))) {
            String[] header = reader.readNext(); // Skip header
            String[] line;
            while ((line = reader.readNext()) != null) {
                String termination = line[4];
                LocalDate termDate = parseDate(termination);
                if (termDate != null && !termDate.isBefore(LocalDate.of(2024, 12, 31))) {
                    records.add(new Record(
                            line[0], line[1], line[3], line[4], line[5], line[6],
                            line[10], line[11], line[12], line[13]
                    ));
                }
            }
        }
        return records;
    }

    private static LocalDate parseDate(String dateStr) {
        try {
            return LocalDate.parse(dateStr.replace("9999", "9999"), DATE_FORMAT);
        } catch (Exception e) {
            return null;
        }
    }

    private static String[] toRow(Record r) {
        return new String[]{
                r.procCode(), r.mod(), r.eff(), r.term(), r.method(), r.allowed(),
                r.mod2(), r.mod3(), r.mod4(), r.active()
        };
    }
}


************************************************************

import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;

import java.io.*;
import java.nio.file.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

public class CsvMonthlyFileMerger {

    record Record(String procCode, String mod, String eff, String term, String method,
                  String allowed, String mod2, String mod3, String mod4, String active) {}

    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("M/d/yyyy");
    private static final List<String> MONTHS = List.of(
            "JAN", "FEB", "MAR", "APR", "MAY", "JUN",
            "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"
    );

    public static void main(String[] args) throws Exception {
        String inputFolder = "src/files/";
        String outputFile = "src/output/Combined.csv";

        // Step 1: Get all monthly CSV files from folder
        List<Path> monthlyFiles = Files.list(Paths.get(inputFolder))
                .filter(Files::isRegularFile)
                .filter(p -> p.toString().endsWith(".csv"))
                .filter(p -> containsMonth(p.getFileName().toString()))
                .collect(Collectors.toList());

        if (monthlyFiles.size() < 3) {
            System.out.println("Less than 3 monthly files found.");
            return;
        }

        // Step 2: Read valid records from all files
        List<Set<Record>> monthlyRecordSets = new ArrayList<>();
        for (Path file : monthlyFiles) {
            monthlyRecordSets.add(readValidRecords(file.toString()));
        }

        // Step 3: Find common records across all files
        Set<Record> commonRecords = new HashSet<>(monthlyRecordSets.get(0));
        for (int i = 1; i < monthlyRecordSets.size(); i++) {
            commonRecords.retainAll(monthlyRecordSets.get(i));
        }

        // Step 4: Collect all records and remove duplicates
        Set<Record> allUniqueRecords = monthlyRecordSets.stream()
                .flatMap(Set::stream)
                .collect(Collectors.toCollection(LinkedHashSet::new)); // preserves order

        // Step 5: Prepare final output - only one entry for common records
        List<Record> finalRecords = allUniqueRecords.stream()
                .distinct()
                .collect(Collectors.toList());

        // Step 6: Write to output
        try (CSVWriter writer = new CSVWriter(new FileWriter(outputFile))) {
            writer.writeNext(new String[]{"Procedure Code", "Modifier", "Effective", "Termination", "Reimbursement Method",
                    "Allowed", "Modifier2", "Modifier3", "Modifier4", "Active"});

            for (Record r : finalRecords) {
                writer.writeNext(toRow(r));
            }
        }

        System.out.println("Final merged output written to: " + outputFile);
    }

    private static boolean containsMonth(String fileName) {
        return MONTHS.stream().anyMatch(m -> fileName.toUpperCase().contains(m));
    }

    private static Set<Record> readValidRecords(String filePath) throws Exception {
        Set<Record> records = new LinkedHashSet<>();
        try (CSVReader reader = new CSVReader(new FileReader(filePath))) {
            String[] header = reader.readNext(); // skip header
            String[] line;
            while ((line = reader.readNext()) != null) {
                String termination = line[4];
                LocalDate termDate = parseDate(termination);
                if (termDate != null && !termDate.isBefore(LocalDate.of(2024, 12, 31))) {
                    records.add(new Record(
                            line[0], line[1], line[3], line[4], line[5], line[6],
                            line[10], line[11], line[12], line[13]
                    ));
                }
            }
        }
        return records;
    }

    private static LocalDate parseDate(String dateStr) {
        try {
            return LocalDate.parse(dateStr.replace("9999", "9999"), DATE_FORMAT);
        } catch (Exception e) {
            return null;
        }
    }

    private static String[] toRow(Record r) {
        return new String[]{
                r.procCode(), r.mod(), r.eff(), r.term(), r.method(), r.allowed(),
                r.mod2(), r.mod3(), r.mod4(), r.active()
        };
    }
}


********************************************************************************************

private static Set<Record> readValidRecords(String filePath) throws Exception {
    Map<String, Record> latestAllowedMap = new LinkedHashMap<>();
    try (CSVReader reader = new CSVReader(new FileReader(filePath))) {
        String[] header = reader.readNext(); // skip header
        String[] line;
        while ((line = reader.readNext()) != null) {
            String term = line[4];
            LocalDate termDate = parseDate(term);
            if (termDate == null || termDate.isBefore(LocalDate.of(2024, 12, 31))) continue;

            String allowedStr = line[6].trim();
            double allowed;
            try {
                allowed = Double.parseDouble(allowedStr);
            } catch (NumberFormatException e) {
                continue; // Skip rows with invalid allowed values
            }

            Record current = new Record(
                    line[0], line[1], line[3], line[4], line[5], line[6],
                    line[10], line[11], line[12], line[13]
            );

            // Key: PROC + MOD1 + MOD2 + MOD3 + MOD4 only for Term = 12/31/9999
            String key = line[0] + "|" + line[1] + "|" + line[10] + "|" + line[11] + "|" + line[12];
            if (term.equals("12/31/9999")) {
                Record existing = latestAllowedMap.get(key);
                if (existing == null || parseDouble(existing.allowed()) < allowed) {
                    latestAllowedMap.put(key, current);
                }
            } else {
                // If term is not 9999, just add as is (no override check)
                latestAllowedMap.put(UUID.randomUUID().toString(), current);
            }
        }
    }
    return new LinkedHashSet<>(latestAllowedMap.values());
}

private static double parseDouble(String value) {
    try {
        return Double.parseDouble(value.trim());
    } catch (Exception e) {
        return 0;
    }
}

***************************************************************************************

import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;

import java.io.*;
import java.nio.file.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

public class CsvMonthlyFileMerger {

    record RecordWithSource(
            String procCode, String mod, String eff, String term, String method,
            String allowed, String mod2, String mod3, String mod4, String active,
            String fileMonth) {

        String getKey() {
            return procCode + "|" + mod + "|" + mod2 + "|" + mod3 + "|" + mod4;
        }

        boolean isOpenTerm() {
            return term.equals("12/31/9999");
        }

        double getAllowedVal() {
            try {
                return Double.parseDouble(allowed.trim());
            } catch (Exception e) {
                return 0;
            }
        }
    }

    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("M/d/yyyy");
    private static final List<String> MONTHS = List.of(
            "JAN", "FEB", "MAR", "APR", "MAY", "JUN",
            "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"
    );

    public static void main(String[] args) throws Exception {
        String inputFolder = "src/files/";
        String outputFile = "src/output/Combined.csv";

        List<Path> monthlyFiles = Files.list(Paths.get(inputFolder))
                .filter(Files::isRegularFile)
                .filter(p -> p.toString().endsWith(".csv"))
                .filter(p -> containsMonth(p.getFileName().toString()))
                .sorted(Comparator.comparingInt(p ->
                        MONTHS.indexOf(extractMonthFromFileName(p.getFileName().toString()).toUpperCase())))
                .collect(Collectors.toList());

        if (monthlyFiles.size() < 1) {
            System.out.println("No valid monthly CSV files found.");
            return;
        }

        // Read and group all records by key
        Map<String, List<RecordWithSource>> groupedByKey = new HashMap<>();
        for (Path file : monthlyFiles) {
            List<RecordWithSource> records = readValidRecords(file.toString());
            for (RecordWithSource r : records) {
                groupedByKey.computeIfAbsent(r.getKey(), k -> new ArrayList<>()).add(r);
            }
        }

        // Process to remove outdated open-end records
        Set<RecordWithSource> finalRecords = new LinkedHashSet<>();
        for (Map.Entry<String, List<RecordWithSource>> entry : groupedByKey.entrySet()) {
            List<RecordWithSource> group = entry.getValue();
            // sort by fileMonth order
            group.sort(Comparator.comparingInt(r -> MONTHS.indexOf(r.fileMonth().toUpperCase())));

            boolean hasClosed = group.stream().anyMatch(r -> !r.isOpenTerm());
            boolean hasOpen = group.stream().anyMatch(RecordWithSource::isOpenTerm);

            if (hasClosed && hasOpen) {
                RecordWithSource latestOpen = group.stream()
                        .filter(RecordWithSource::isOpenTerm)
                        .max(Comparator.comparingDouble(RecordWithSource::getAllowedVal))
                        .orElse(null);

                group.stream()
                        .filter(r -> !r.isOpenTerm())  // keep closed ones
                        .forEach(finalRecords::add);

                if (latestOpen != null)
                    finalRecords.add(latestOpen);
            } else {
                // Only open or only closed → add all
                finalRecords.addAll(group);
            }
        }

        // Write output
        try (CSVWriter writer = new CSVWriter(new FileWriter(outputFile))) {
            writer.writeNext(new String[]{"Procedure Code", "Modifier", "Effective", "Termination", "Reimbursement Method",
                    "Allowed", "Modifier2", "Modifier3", "Modifier4", "Active", "File Name"});

            for (RecordWithSource r : finalRecords) {
                writer.writeNext(new String[]{
                        r.procCode(), r.mod(), r.eff(), r.term(), r.method(), r.allowed(),
                        r.mod2(), r.mod3(), r.mod4(), r.active(), r.fileMonth()
                });
            }
        }

        System.out.println("✅ Combined file written to: " + outputFile);
    }

    private static boolean containsMonth(String fileName) {
        return MONTHS.stream().anyMatch(m -> fileName.toUpperCase().contains(m));
    }

    private static String extractMonthFromFileName(String fileName) {
        return MONTHS.stream()
                .filter(fileName.toUpperCase()::contains)
                .findFirst()
                .orElse("Unknown");
    }

    private static List<RecordWithSource> readValidRecords(String filePath) throws Exception {
        String month = extractMonthFromFileName(filePath);
        List<RecordWithSource> records = new ArrayList<>();

        try (CSVReader reader = new CSVReader(new FileReader(filePath))) {
            reader.readNext(); // skip header
            String[] line;
            while ((line = reader.readNext()) != null) {
                String term = line[4];
                LocalDate termDate = parseDate(term);
                if (termDate == null || termDate.isBefore(LocalDate.of(2024, 12, 31))) continue;

                records.add(new RecordWithSource(
                        line[0], line[1], line[3], line[4], line[5], line[6],
                        line[10], line[11], line[12], line[13], month
                ));
            }
        }
        return records;
    }

    private static LocalDate parseDate(String dateStr) {
        try {
            return LocalDate.parse(dateStr, DATE_FORMAT);
        } catch (Exception e) {
            return null;
        }
    }
}



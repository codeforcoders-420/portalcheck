import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.apache.poi.xssf.streaming.SXSSFSheet;

import java.io.*;
import java.math.BigDecimal;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;

public class CompareDTvsDB_Complete {

    // ====== FOLDERS ======
    private static final Path INPUT_DIR  = Paths.get("C:/data/in");   // <-- change
    private static final Path OUTPUT_DIR = Paths.get("C:/data/out");  // <-- change

    // ====== FILE DISCOVERY ======
    private static final String DT_KEYWORD = "DT";
    private static final String DB_KEYWORD = "DUMP";
    private static final String DT_EXACT_FILENAME = "";
    private static final String DB_EXACT_FILENAME = "";

    // ====== BEHAVIOR ======
    private static final boolean REQUIRE_DB_MOD3_MOD4_BLANK = false;

    private static final String OUTPUT_FILENAME = "Differences Record.xlsx";
    private static final String OUTPUT_SHEET    = "Differences";

    private static final DateTimeFormatter OUT_DTF = DateTimeFormatter.ofPattern("MM/dd/yyyy");
    private static final List<DateTimeFormatter> IN_DTFS = List.of(
            DateTimeFormatter.ofPattern("M/d/yyyy"),
            DateTimeFormatter.ofPattern("MM/dd/yyyy"),
            DateTimeFormatter.ofPattern("yyyy-MM-dd"),
            DateTimeFormatter.ofPattern("M/d/yy"),
            DateTimeFormatter.ofPattern("MM/dd/yy")
    );

    // Open-ended date used by DB/DT to indicate “active” records
    private static final LocalDate OPEN_END = LocalDate.of(9999, 12, 31);

    public static void main(String[] args) throws Exception {
        Files.createDirectories(INPUT_DIR);
        Files.createDirectories(OUTPUT_DIR);

        Path dtPath = DT_EXACT_FILENAME.isBlank()
                ? latestXlsxByKeyword(INPUT_DIR, DT_KEYWORD)
                : INPUT_DIR.resolve(DT_EXACT_FILENAME);

        Path dbPath = DB_EXACT_FILENAME.isBlank()
                ? latestXlsxByKeyword(INPUT_DIR, DB_KEYWORD)
                : INPUT_DIR.resolve(DB_EXACT_FILENAME);

        if (dtPath == null) throw new IllegalStateException("DT file not found in " + INPUT_DIR + " (keyword=" + DT_KEYWORD + ").");
        if (dbPath == null) throw new IllegalStateException("DB dump file not found in " + INPUT_DIR + " (keyword=" + DB_KEYWORD + ").");

        try (Workbook dtWb = new XSSFWorkbook(Files.newInputStream(dtPath));
             Workbook dbWb = new XSSFWorkbook(Files.newInputStream(dbPath))) {

            Sheet dtSheet = dtWb.getSheetAt(0);
            Sheet dbSheet = dbWb.getSheetAt(0);

            // Build DB index first
            DbIndex db = buildDbIndex(dbSheet);

            // Pre-scan DT once to know which triplets have an active (open-ended) row
            DtScan scan = scanDtForOpenEnded(dtSheet);

            Path outPath = OUTPUT_DIR.resolve(OUTPUT_FILENAME);
            writeDifferences(dtSheet, db, scan, outPath);
        }
    }

    // ---------- file discovery ----------
    private static Path latestXlsxByKeyword(Path dir, String keyword) throws IOException {
        final String kw = keyword == null ? "" : keyword.toLowerCase(Locale.ROOT);
        Path best = null;
        FileTime bestTime = null;

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, "*.xlsx")) {
            for (Path p : stream) {
                String name = p.getFileName().toString().toLowerCase(Locale.ROOT);
                if (!kw.isBlank() && !name.contains(kw)) continue;

                BasicFileAttributes attrs = Files.readAttributes(p, BasicFileAttributes.class);
                if (best == null || attrs.lastModifiedTime().compareTo(bestTime) > 0) {
                    best = p;
                    bestTime = attrs.lastModifiedTime();
                }
            }
        }
        return best;
    }

    // ---------- data structures ----------
    private record ExactKey(String proc, String mod, String mod2, LocalDate eff, LocalDate term, String rate4dp) { }
    private record PartialKey(String proc, String mod, String mod2, LocalDate term, String rate4dp) { }
    private record TripleKey(String proc, String mod, String mod2) { }

    private static class DbRow {
        String proc, mod, mod2, mod3, mod4, allowed4;
        LocalDate eff, term;
    }

    private static class DbIndex {
        final Set<ExactKey> exact = new HashSet<>();
        final Set<PartialKey> partial = new HashSet<>();
        final Set<TripleKey> triplets = new HashSet<>();
        final Map<TripleKey, List<DbRow>> byTriplet = new HashMap<>();
    }

    private static class DtScan {
        // does DT contain any active (end=9999-12-31) row for this triplet?
        final Map<TripleKey, Boolean> hasOpenEnded = new HashMap<>();
        // header column indexes (for reuse)
        int cPROC, cMOD, cMOD2, cSD, cED, cRATE;
    }

    // ---------- DB indexing ----------
    private static DbIndex buildDbIndex(Sheet dbSheet) {
        DataFormatter fmt = new DataFormatter();
        Map<String,Integer> col = headerMap(dbSheet.getRow(dbSheet.getFirstRowNum()), fmt);

        int pcode = key(col, "Procedure Code", "Procedure", "ProcedureCode");
        int mod   = key(col, "Modifier", "Mod");
        int mod2  = key(col, "Modifier 2", "Modifier2", "Mod2");
        int mod3  = key(col, "Modifier 3", "Modifier3", "Mod3");
        int mod4  = key(col, "Modifier 4", "Modifier4", "Mod4");
        int eff   = key(col, "Effective", "Start Date", "Eff");
        int term  = key(col, "Termination", "End Date", "Term");
        int allow = key(col, "Allowed", "Rate");

        DbIndex idx = new DbIndex();

        for (int r = dbSheet.getFirstRowNum()+1; r <= dbSheet.getLastRowNum(); r++) {
            Row row = dbSheet.getRow(r);
            if (row == null) continue;

            String proc = norm(fmt.formatCellValue(row.getCell(pcode, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            if (proc.isEmpty()) continue;

            String m1  = norm(fmt.formatCellValue(row.getCell(mod,   Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            String m2  = norm(fmt.formatCellValue(row.getCell(mod2,  Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            String m3  = norm(fmt.formatCellValue(row.getCell(mod3,  Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            String m4  = norm(fmt.formatCellValue(row.getCell(mod4,  Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            LocalDate e1  = parseDate(fmt.formatCellValue(row.getCell(eff,  Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            LocalDate e2  = parseDate(fmt.formatCellValue(row.getCell(term, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            String rate4  = rateTo4(fmt.formatCellValue(row.getCell(allow, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));

            idx.exact.add(new ExactKey(proc, m1, m2, e1, e2, rate4));
            idx.partial.add(new PartialKey(proc, m1, m2, e2, rate4));

            if (REQUIRE_DB_MOD3_MOD4_BLANK) {
                if (m3.isEmpty() && m4.isEmpty()) idx.triplets.add(new TripleKey(proc, m1, m2));
            } else {
                idx.triplets.add(new TripleKey(proc, m1, m2));
            }

            DbRow dr = new DbRow();
            dr.proc = proc; dr.mod = m1; dr.mod2 = m2; dr.mod3 = m3; dr.mod4 = m4;
            dr.eff = e1; dr.term = e2; dr.allowed4 = rate4;

            idx.byTriplet.computeIfAbsent(new TripleKey(proc, m1, m2), k -> new ArrayList<>()).add(dr);
        }
        return idx;
    }

    // ---------- DT pre-scan for open-ended presence ----------
    private static DtScan scanDtForOpenEnded(Sheet dtSheet) {
        DataFormatter fmt = new DataFormatter();
        Map<String,Integer> col = headerMap(dtSheet.getRow(dtSheet.getFirstRowNum()), fmt);

        DtScan scan = new DtScan();
        scan.cPROC = key(col, "PROC", "PROCEDURE CODE", "Procedure", "ProcedureCode");
        scan.cMOD  = key(col, "MOD", "Modifier", "Mod");
        scan.cMOD2 = key(col, "MOD2", "Modifier 2", "Modifier2", "Mod2");
        scan.cSD   = key(col, "Start Date", "Effective", "Eff");
        scan.cED   = key(col, "End Date", "Termination", "Term");
        scan.cRATE = key(col, "Rate", "Allowed");

        for (int r = dtSheet.getFirstRowNum()+1; r <= dtSheet.getLastRowNum(); r++) {
            Row row = dtSheet.getRow(r);
            if (row == null) continue;

            String proc = norm(fmt.formatCellValue(row.getCell(scan.cPROC, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            if (proc.isEmpty()) continue;
            String mod  = norm(fmt.formatCellValue(row.getCell(scan.cMOD,  Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            String mod2 = norm(fmt.formatCellValue(row.getCell(scan.cMOD2, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            LocalDate end = parseDate(fmt.formatCellValue(row.getCell(scan.cED,   Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));

            TripleKey k = new TripleKey(proc, mod, mod2);
            if (OPEN_END.equals(end)) scan.hasOpenEnded.put(k, true);
        }
        return scan;
    }

    // ---------- write differences ----------
    private static void writeDifferences(Sheet dtSheet, DbIndex db, DtScan scan, Path outPath) throws IOException {
        DataFormatter fmt = new DataFormatter();

        // track triplets where we already wrote a Rate change (to suppress Terminate)
        Set<TripleKey> rateChangeWritten = new HashSet<>();

        try (SXSSFWorkbook outWb = new SXSSFWorkbook(1000)) {
            outWb.setCompressTempFiles(true);
            SXSSFSheet outSh = outWb.createSheet(OUTPUT_SHEET);

            int wr = 0;
            Row h = outSh.createRow(wr++);
            write(h, 0, "Procedure code");
            write(h, 1, "Mod");
            write(h, 2, "Mod 1");
            write(h, 3, "Mod2");
            write(h, 4, "Mod3");
            write(h, 5, "Mod 4");
            write(h, 6, "Effective Date");
            write(h, 7, "Termination Date");
            write(h, 8, "Pricing Method");
            write(h, 9, "New Rate");
            write(h,10, "Old Rate");
            write(h,11, "Comments");

            for (int r = dtSheet.getFirstRowNum()+1; r <= dtSheet.getLastRowNum(); r++) {
                Row row = dtSheet.getRow(r);
                if (row == null) continue;

                String proc = norm(fmt.formatCellValue(row.getCell(scan.cPROC, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
                if (proc.isEmpty()) continue;

                String mod  = norm(fmt.formatCellValue(row.getCell(scan.cMOD,  Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
                String mod2 = norm(fmt.formatCellValue(row.getCell(scan.cMOD2, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
                LocalDate start = parseDate(fmt.formatCellValue(row.getCell(scan.cSD,   Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
                LocalDate end   = parseDate(fmt.formatCellValue(row.getCell(scan.cED,   Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
                String rate4    = rateTo4(fmt.formatCellValue(row.getCell(scan.cRATE, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));

                // 1) Exact ignore
                if (db.exact.contains(new ExactKey(proc, mod, mod2, start, end, rate4))) continue;

                // 2) Partial ignore
                if (db.partial.contains(new PartialKey(proc, mod, mod2, end, rate4))) continue;

                // 3) Triplet present?
                TripleKey trip = new TripleKey(proc, mod, mod2);
                List<DbRow> candidates = db.byTriplet.get(trip);

                if (candidates == null || candidates.isEmpty()) {
                    // ---- NEW CODE ----
                    Row out = outSh.createRow(wr++);
                    int c = 0;
                    write(out, c++, proc);
                    write(out, c++, mod);
                    write(out, c++, mod2);           // Mod 1 from DT.MOD2
                    write(out, c++, "");             // Mod2
                    write(out, c++, "");             // Mod3
                    write(out, c++, "");             // Mod 4
                    write(out, c++, fmtDate(start)); // Effective
                    write(out, c++, fmtDate(end));   // Termination
                    write(out, c++, "Allowed");      // Pricing Method
                    write(out, c++, rate4);          // New Rate
                    write(out, c++, "N/A");          // Old Rate
                    write(out, c++, "New Code");     // Comments
                    continue;
                }

                // ---- For existing triplet: Rate change / Terminate ----
                DbRow best = pickBest(candidates, start, end);
                if (best != null) {
                    boolean rateDiff = !rate4.equals(best.allowed4);
                    boolean canCompareDates = (end != null && best.term != null);

                    if (rateDiff) {
                        // ---- RATE CHANGE ----
                        Row out = outSh.createRow(wr++);
                        int c = 0;
                        write(out, c++, proc);
                        write(out, c++, mod);
                        write(out, c++, mod2);
                        write(out, c++, "");
                        write(out, c++, "");
                        write(out, c++, "");
                        write(out, c++, fmtDate(start));
                        write(out, c++, fmtDate(end));
                        write(out, c++, "Allowed");
                        write(out, c++, rate4);          // New Rate (DT)
                        write(out, c++, best.allowed4);  // Old Rate (DB)
                        write(out, c++, "Rate change");
                        rateChangeWritten.add(trip);      // suppress Terminate later
                        continue;
                    }

                    // ---- TERMINATE only if:
                    // 1) dates comparable AND DT ends before DB active/covering term, AND
                    // 2) there is NO active DT row for this triplet, AND
                    // 3) we didn't already write a Rate change for this triplet
                    boolean hasActiveDt = scan.hasOpenEnded.getOrDefault(trip, false);
                    if (canCompareDates
                            && end.isBefore(best.term)
                            && !hasActiveDt
                            && !rateChangeWritten.contains(trip)) {
                        Row out = outSh.createRow(wr++);
                        int c = 0;
                        write(out, c++, proc);
                        write(out, c++, mod);
                        write(out, c++, mod2);
                        write(out, c++, "");
                        write(out, c++, "");
                        write(out, c++, "");
                        write(out, c++, fmtDate(start));  // Effective (DT)
                        write(out, c++, fmtDate(end));    // Termination (DT)
                        write(out, c++, "Allowed");
                        write(out, c++, rate4);           // New Rate (DT)
                        write(out, c++, best.allowed4);   // Old Rate (DB)
                        write(out, c++, "Terminate");
                        continue;
                    }
                }
                // else: nothing to write
            }

            for (int c = 0; c <= 11; c++) outSh.trackColumnForAutoSizing(c);
            for (int c = 0; c <= 11; c++) outSh.autoSizeColumn(c);

            try (OutputStream os = Files.newOutputStream(outPath)) {
                outWb.write(os);
            }
            outWb.dispose();
        }
    }

    // ---------- choose best DB row for a DT period ----------
    private static boolean overlaps(LocalDate aStart, LocalDate aEnd, LocalDate bStart, LocalDate bEnd) {
        if (aStart == null || aEnd == null || bStart == null || bEnd == null) return false;
        return !aStart.isAfter(bEnd) && !bStart.isAfter(aEnd);
    }

    private static DbRow pickBest(List<DbRow> rows, LocalDate dStart, LocalDate dEnd) {
        if (rows == null || rows.isEmpty()) return null;

        List<DbRow> overlapping = new ArrayList<>();
        for (DbRow r : rows) if (overlaps(dStart, dEnd, r.eff, r.term)) overlapping.add(r);

        if (!overlapping.isEmpty()) {
            overlapping.sort(Comparator
                    .comparing((DbRow r) -> r.eff == null ? LocalDate.MIN : r.eff)
                    .reversed());
            for (DbRow r : overlapping) if (r.eff == null || !r.eff.isAfter(dStart)) return r;
            return overlapping.get(0);
        }

        DbRow prior = null;
        for (DbRow r : rows) {
            if (r.eff != null && !r.eff.isAfter(dStart)) {
                if (prior == null || r.eff.isAfter(prior.eff)) prior = r;
            }
        }
        if (prior != null) return prior;

        rows.sort(Comparator.comparing(r -> r.eff == null ? LocalDate.MAX : r.eff));
        return rows.get(0);
    }

    // ---------- common helpers ----------
    private static Map<String,Integer> headerMap(Row header, DataFormatter fmt) {
        if (header == null) throw new IllegalArgumentException("Missing header row.");
        Map<String,Integer> map = new HashMap<>();
        for (int c = header.getFirstCellNum(); c < header.getLastCellNum(); c++) {
            Cell cell = header.getCell(c);
            String key = cell == null ? "" : fmt.formatCellValue(cell).trim();
            if (!key.isEmpty()) map.put(key.toUpperCase(Locale.ROOT), c);
        }
        return map;
    }

    private static int key(Map<String,Integer> col, String... aliases) {
        for (String a : aliases) {
            Integer idx = col.get(a.toUpperCase(Locale.ROOT));
            if (idx != null) return idx;
        }
        throw new IllegalArgumentException("Expected one of columns: " + Arrays.toString(aliases));
    }

    private static String norm(String s) {
        if (s == null) return "";
        s = s.trim();
        if (s.equalsIgnoreCase("null")) return "";
        return s.toUpperCase(Locale.ROOT);
    }

    private static LocalDate parseDate(String s) {
        s = s == null ? "" : s.trim();
        if (s.isEmpty()) return null;
        for (DateTimeFormatter f: IN_DTFS) {
            try { return LocalDate.parse(s, f); } catch (DateTimeParseException ignored) {}
        }
        try {
            double serial = Double.parseDouble(s);
            return LocalDate.of(1899,12,30).plusDays((long)serial);
        } catch (Exception ignored) {}
        return null;
    }

    private static String fmtDate(LocalDate d) {
        return d == null ? "" : OUT_DTF.format(d);
    }

    private static String rateTo4(String raw) {
        String s = raw == null ? "" : raw.trim();
        if (s.isEmpty()) return "0.0000";
        s = s.replace("$","").replace(",","");
        try {
            BigDecimal bd = new BigDecimal(s);
            return bd.setScale(4, BigDecimal.ROUND_HALF_UP).toPlainString();
        } catch (NumberFormatException e) {
            return "0.0000";
        }
    }

    private static void write(Row r, int c, String v) {
        Cell cell = r.createCell(c, CellType.STRING);
        cell.setCellValue(v == null ? "" : v);
    }
}

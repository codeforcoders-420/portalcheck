import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.apache.poi.xssf.streaming.SXSSFSheet;

import java.io.*;
import java.math.BigDecimal;
import java.nio.file.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;

public class CompareDTvsDB_DirectPaths {

    // ---- Set these OR pass 3 args: <DT.xlsx> <DB.xlsx> <Output.xlsx>
    private static final String DT_PATH_DEFAULT  = "C:/data/in/DT.xlsx";
    private static final String DB_PATH_DEFAULT  = "C:/data/in/DB.xlsx";
    private static final String OUT_PATH_DEFAULT = "C:/data/out/Differences Record.xlsx";

    private static final boolean REQUIRE_DB_MOD3_MOD4_BLANK = false;

    private static final String OUTPUT_SHEET = "Differences";
    private static final DateTimeFormatter OUT_DTF = DateTimeFormatter.ofPattern("MM/dd/yyyy");
    private static final List<DateTimeFormatter> IN_DTFS = List.of(
            DateTimeFormatter.ofPattern("M/d/yyyy"),
            DateTimeFormatter.ofPattern("MM/dd/yyyy"),
            DateTimeFormatter.ofPattern("yyyy-MM-dd"),
            DateTimeFormatter.ofPattern("M/d/yy"),
            DateTimeFormatter.ofPattern("MM/dd/yy")
    );
    private static final LocalDate OPEN_END = LocalDate.of(9999, 12, 31);

    public static void main(String[] args) throws Exception {
        Path dtPath  = Paths.get(args.length >= 1 ? args[0] : DT_PATH_DEFAULT);
        Path dbPath  = Paths.get(args.length >= 2 ? args[1] : DB_PATH_DEFAULT);
        Path outPath = Paths.get(args.length >= 3 ? args[2] : OUT_PATH_DEFAULT);

        try (Workbook dtWb = new XSSFWorkbook(Files.newInputStream(dtPath));
             Workbook dbWb = new XSSFWorkbook(Files.newInputStream(dbPath))) {

            Sheet dtSheet = dtWb.getSheetAt(0);
            Sheet dbSheet = dbWb.getSheetAt(0);

            DbIndex db = buildDbIndex(dbSheet);
            DtScan scan = scanDtForOpenEnded(dtSheet);

            writeDifferences(dtSheet, db, scan, outPath);
        }
    }

    // ---------- data structures ----------
    private record ExactKey(String proc, String mod, String mod2, LocalDate eff, LocalDate term, String rate4dp) { }
    private record PartialKey(String proc, String mod, String mod2, LocalDate term, String rate4dp) { }
    private record TripleKey(String proc, String mod, String mod2) { }

    private static class DbRow {
        String proc, mod, mod2, mod3, mod4, allowed4;
        LocalDate eff, term;
    }

    private static class DbIndex {
        final Set<ExactKey> exact = new HashSet<>();
        final Set<PartialKey> partial = new HashSet<>();
        final Set<TripleKey> triplets = new HashSet<>();
        final Map<TripleKey, List<DbRow>> byTriplet = new HashMap<>();
    }

    private static class DtScan {
        final Map<TripleKey, Boolean> hasOpenEnded = new HashMap<>();
        int cPROC, cMOD, cMOD2, cSD, cED, cRATE;
    }

    // ---------- DB indexing ----------
    private static DbIndex buildDbIndex(Sheet dbSheet) {
        DataFormatter fmt = new DataFormatter();
        Map<String,Integer> col = headerMap(dbSheet.getRow(dbSheet.getFirstRowNum()), fmt);

        int pcode = key(col, "Procedure Code", "Procedure", "ProcedureCode");
        int mod   = key(col, "Modifier", "Mod");
        int mod2  = key(col, "Modifier 2", "Modifier2", "Mod2");
        int mod3  = key(col, "Modifier 3", "Modifier3", "Mod3");
        int mod4  = key(col, "Modifier 4", "Modifier4", "Mod4");
        int eff   = key(col, "Effective", "Start Date", "Eff");
        int term  = key(col, "Termination", "End Date", "Term");
        int allow = key(col, "Allowed", "Rate");

        DbIndex idx = new DbIndex();

        for (int r = dbSheet.getFirstRowNum()+1; r <= dbSheet.getLastRowNum(); r++) {
            Row row = dbSheet.getRow(r);
            if (row == null) continue;

            String proc = norm(fmt.formatCellValue(row.getCell(pcode, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            if (proc.isEmpty()) continue;

            String m1  = norm(fmt.formatCellValue(row.getCell(mod,   Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            String m2  = norm(fmt.formatCellValue(row.getCell(mod2,  Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            String m3  = norm(fmt.formatCellValue(row.getCell(mod3,  Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            String m4  = norm(fmt.formatCellValue(row.getCell(mod4,  Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            LocalDate e1  = parseDate(fmt.formatCellValue(row.getCell(eff,  Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            LocalDate e2  = parseDate(fmt.formatCellValue(row.getCell(term, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            String rate4  = rateTo4(fmt.formatCellValue(row.getCell(allow, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));

            idx.exact.add(new ExactKey(proc, m1, m2, e1, e2, rate4));
            idx.partial.add(new PartialKey(proc, m1, m2, e2, rate4));

            if (REQUIRE_DB_MOD3_MOD4_BLANK) {
                if (m3.isEmpty() && m4.isEmpty()) idx.triplets.add(new TripleKey(proc, m1, m2));
            } else {
                idx.triplets.add(new TripleKey(proc, m1, m2));
            }

            DbRow dr = new DbRow();
            dr.proc = proc; dr.mod = m1; dr.mod2 = m2; dr.mod3 = m3; dr.mod4 = m4;
            dr.eff = e1; dr.term = e2; dr.allowed4 = rate4;

            idx.byTriplet.computeIfAbsent(new TripleKey(proc, m1, m2), k -> new ArrayList<>()).add(dr);
        }
        return idx;
    }

    // ---------- DT pre-scan for open-ended presence ----------
    private static DtScan scanDtForOpenEnded(Sheet dtSheet) {
        DataFormatter fmt = new DataFormatter();
        Map<String,Integer> col = headerMap(dtSheet.getRow(dtSheet.getFirstRowNum()), fmt);

        DtScan scan = new DtScan();
        scan.cPROC = key(col, "PROC", "PROCEDURE CODE", "Procedure", "ProcedureCode");
        scan.cMOD  = key(col, "MOD", "Modifier", "Mod");
        scan.cMOD2 = key(col, "MOD2", "Modifier 2", "Modifier2", "Mod2");
        scan.cSD   = key(col, "Start Date", "Effective", "Eff");
        scan.cED   = key(col, "End Date", "Termination", "Term");
        scan.cRATE = key(col, "Rate", "Allowed");

        for (int r = dtSheet.getFirstRowNum()+1; r <= dtSheet.getLastRowNum(); r++) {
            Row row = dtSheet.getRow(r);
            if (row == null) continue;

            String proc = norm(fmt.formatCellValue(row.getCell(scan.cPROC, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            if (proc.isEmpty()) continue;
            String mod  = norm(fmt.formatCellValue(row.getCell(scan.cMOD,  Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            String mod2 = norm(fmt.formatCellValue(row.getCell(scan.cMOD2, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
            LocalDate end = parseDate(fmt.formatCellValue(row.getCell(scan.cED,   Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));

            TripleKey k = new TripleKey(proc, mod, mod2);
            if (LocalDate.of(9999,12,31).equals(end)) scan.hasOpenEnded.put(k, true);
        }
        return scan;
    }

    // ---------- write differences ----------
    private static void writeDifferences(Sheet dtSheet, DbIndex db, DtScan scan, Path outPath) throws IOException {
        DataFormatter fmt = new DataFormatter();
        Set<TripleKey> rateChangeWritten = new HashSet<>();

        try (SXSSFWorkbook outWb = new SXSSFWorkbook(1000)) {
            outWb.setCompressTempFiles(true);
            SXSSFSheet outSh = outWb.createSheet(OUTPUT_SHEET);

            int wr = 0;
            Row h = outSh.createRow(wr++);
            write(h, 0, "Procedure code");
            write(h, 1, "Mod");
            write(h, 2, "Mod 1");
            write(h, 3, "Mod2");
            write(h, 4, "Mod3");
            write(h, 5, "Mod 4");
            write(h, 6, "Effective Date");
            write(h, 7, "Termination Date");
            write(h, 8, "Pricing Method");
            write(h, 9, "New Rate");
            write(h,10, "Old Rate");
            write(h,11, "Comments");

            for (int r = dtSheet.getFirstRowNum()+1; r <= dtSheet.getLastRowNum(); r++) {
                Row row = dtSheet.getRow(r);
                if (row == null) continue;

                String proc = norm(fmt.formatCellValue(row.getCell(scan.cPROC, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
                if (proc.isEmpty()) continue;

                String mod  = norm(fmt.formatCellValue(row.getCell(scan.cMOD,  Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
                String mod2 = norm(fmt.formatCellValue(row.getCell(scan.cMOD2, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
                LocalDate start = parseDate(fmt.formatCellValue(row.getCell(scan.cSD,   Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
                LocalDate end   = parseDate(fmt.formatCellValue(row.getCell(scan.cED,   Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));
                String rate4    = rateTo4(fmt.formatCellValue(row.getCell(scan.cRATE, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL)));

                // 1) Exact ignore
                if (db.exact.contains(new ExactKey(proc, mod, mod2, start, end, rate4))) continue;

                // 2) Partial ignore
                if (db.partial.contains(new PartialKey(proc, mod, mod2, end, rate4))) continue;

                // 3) Triplet present?
                TripleKey trip = new TripleKey(proc, mod, mod2);
                List<DbRow> candidates = db.byTriplet.get(trip);

                if (candidates == null || candidates.isEmpty()) {
                    Row out = outSh.createRow(wr++);
                    int c = 0;
                    write(out, c++, proc);
                    write(out, c++, mod);
                    write(out, c++, mod2);
                    write(out, c++, "");
                    write(out, c++, "");
                    write(out, c++, "");
                    write(out, c++, fmtDate(start));
                    write(out, c++, fmtDate(end));
                    write(out, c++, "Allowed");
                    write(out, c++, rate4);
                    write(out, c++, "N/A");
                    write(out, c++, "New Code");
                    continue;
                }

                DbRow best = pickBest(candidates, start, end);
                if (best != null) {
                    boolean rateDiff = !rate4.equals(best.allowed4);
                    boolean canCompareDates = (end != null && best.term != null);

                    if (rateDiff) {
                        Row out = outSh.createRow(wr++);
                        int c = 0;
                        write(out, c++, proc);
                        write(out, c++, mod);
                        write(out, c++, mod2);
                        write(out, c++, "");
                        write(out, c++, "");
                        write(out, c++, "");
                        write(out, c++, fmtDate(start));
                        write(out, c++, fmtDate(end));
                        write(out, c++, "Allowed");
                        write(out, c++, rate4);
                        write(out, c++, best.allowed4);
                        write(out, c++, "Rate change");
                        rateChangeWritten.add(trip);
                        continue;
                    }

                    boolean hasActiveDt = scan.hasOpenEnded.getOrDefault(trip, false);
                    if (canCompareDates && end.isBefore(best.term) && !hasActiveDt && !rateChangeWritten.contains(trip)) {
                        Row out = outSh.createRow(wr++);
                        int c = 0;
                        write(out, c++, proc);
                        write(out, c++, mod);
                        write(out, c++, mod2);
                        write(out, c++, "");
                        write(out, c++, "");
                        write(out, c++, "");
                        write(out, c++, fmtDate(start));
                        write(out, c++, fmtDate(end));
                        write(out, c++, "Allowed");
                        write(out, c++, rate4);
                        write(out, c++, best.allowed4);
                        write(out, c++, "Terminate");
                        continue;
                    }

                    // Fallback: review manually
                    Row out = outSh.createRow(wr++);
                    int c = 0;
                    write(out, c++, proc);
                    write(out, c++, mod);
                    write(out, c++, mod2);
                    write(out, c++, "");
                    write(out, c++, "");
                    write(out, c++, "");
                    write(out, c++, fmtDate(start));
                    write(out, c++, fmtDate(end));
                    write(out, c++, "Allowed");
                    write(out, c++, rate4);
                    write(out, c++, best.allowed4);
                    write(out, c++, "Review these changes manually - Not fit into A/D/C scenarios");
                    continue;
                }

                // No best match (rare) -> review
                Row out = outSh.createRow(wr++);
                int c = 0;
                write(out, c++, proc);
                write(out, c++, mod);
                write(out, c++, mod2);
                write(out, c++, "");
                write(out, c++, "");
                write(out, c++, "");
                write(out, c++, fmtDate(start));
                write(out, c++, fmtDate(end));
                write(out, c++, "Allowed");
                write(out, c++, rate4);
                write(out, c++, "N/A");
                write(out, c++, "Review these changes manually - Not fit into A/D/C scenarios");
            }

            for (int c = 0; c <= 11; c++) outSh.trackColumnForAutoSizing(c);
            for (int c = 0; c <= 11; c++) outSh.autoSizeColumn(c);

            if (outPath.getParent() != null) Files.createDirectories(outPath.getParent());
            try (OutputStream os = Files.newOutputStream(outPath)) {
                outWb.write(os);
            }
            outWb.dispose();
        }
    }

    // ---------- choose best DB row for a DT period ----------
    private static boolean overlaps(LocalDate aStart, LocalDate aEnd, LocalDate bStart, LocalDate bEnd) {
        if (aStart == null || aEnd == null || bStart == null || bEnd == null) return false;
        return !aStart.isAfter(bEnd) && !bStart.isAfter(aEnd);
    }
    private static DbRow pickBest(List<DbRow> rows, LocalDate dStart, LocalDate dEnd) {
        if (rows == null || rows.isEmpty()) return null;
        List<DbRow> overlapping = new ArrayList<>();
        for (DbRow r : rows) if (overlaps(dStart, dEnd, r.eff, r.term)) overlapping.add(r);
        if (!overlapping.isEmpty()) {
            overlapping.sort(Comparator.comparing((DbRow r) -> r.eff == null ? LocalDate.MIN : r.eff).reversed());
            for (DbRow r : overlapping) if (r.eff == null || !r.eff.isAfter(dStart)) return r;
            return overlapping.get(0);
        }
        DbRow prior = null;
        for (DbRow r : rows) {
            if (r.eff != null && !r.eff.isAfter(dStart)) {
                if (prior == null || r.eff.isAfter(prior.eff)) prior = r;
            }
        }
        if (prior != null) return prior;
        rows.sort(Comparator.comparing(r -> r.eff == null ? LocalDate.MAX : r.eff));
        return rows.get(0);
    }

    // ---------- helpers ----------
    private static Map<String,Integer> headerMap(Row header, DataFormatter fmt) {
        if (header == null) throw new IllegalArgumentException("Missing header row.");
        Map<String,Integer> map = new HashMap<>();
        for (int c = header.getFirstCellNum(); c < header.getLastRowNum(); c++) { /* fallback if needed */ }
        for (int c = header.getFirstCellNum(); c < header.getLastCellNum(); c++) {
            Cell cell = header.getCell(c);
            String key = cell == null ? "" : fmt.formatCellValue(cell).trim();
            if (!key.isEmpty()) map.put(key.toUpperCase(Locale.ROOT), c);
        }
        return map;
    }
    private static int key(Map<String,Integer> col, String... aliases) {
        for (String a : aliases) {
            Integer idx = col.get(a.toUpperCase(Locale.ROOT));
            if (idx != null) return idx;
        }
        throw new IllegalArgumentException("Expected one of columns: " + Arrays.toString(aliases));
    }
    private static String norm(String s) {
        if (s == null) return "";
        s = s.trim();
        if (s.equalsIgnoreCase("null")) return "";
        return s.toUpperCase(Locale.ROOT);
    }
    private static LocalDate parseDate(String s) {
        s = s == null ? "" : s.trim();
        if (s.isEmpty()) return null;
        for (DateTimeFormatter f: IN_DTFS) {
            try { return LocalDate.parse(s, f); } catch (DateTimeParseException ignored) {}
        }
        try {
            double serial = Double.parseDouble(s);
            return LocalDate.of(1899,12,30).plusDays((long)serial);
        } catch (Exception ignored) {}
        return null;
    }
    private static String fmtDate(LocalDate d) { return d == null ? "" : OUT_DTF.format(d); }
    private static String rateTo4(String raw) {
        String s = raw == null ? "" : raw.trim();
        if (s.isEmpty()) return "0.0000";
        s = s.replace("$","").replace(",","");
        try { return new BigDecimal(s).setScale(4, BigDecimal.ROUND_HALF_UP).toPlainString(); }
        catch (NumberFormatException e) { return "0.0000"; }
    }
    private static void write(Row r, int c, String v) {
        Cell cell = r.createCell(c, CellType.STRING);
        cell.setCellValue(v == null ? "" : v);
    }
}

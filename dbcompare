import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.apache.poi.xssf.streaming.SXSSFSheet;

import java.io.*;
import java.math.BigDecimal;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;

/**
 * Compare a DT worksheet (left) vs a Database dump (right) and write "New Code" rows to:
 *   <OUTPUT_DIR>/Differences Record.xlsx
 *
 * HOW TO USE:
 *  1) Set INPUT_DIR to the folder that contains both workbooks.
 *  2) Set OUTPUT_DIR to where you want the result workbook written.
 *  3) Option A (recommended): keep DT_KEYWORD / DB_KEYWORD to let the program pick the most-recent .xlsx
 *     whose filename contains the keyword (case-insensitive).
 *     Example file names that would match:
 *       ...\DT_Span_20250827.xlsx      (contains "DT")
 *       ...\Database_Dump_20250827.xlsx (contains "DUMP" or "DB")
 *     Adjust the keywords below to match your naming.
 *  4) Option B: set DT_EXACT_FILENAME / DB_EXACT_FILENAME (non-empty) to use exact file names instead.
 *
 * Maven deps:
 *   org.apache.poi:poi-ooxml:5.2.5
 *   org.apache.poi:poi:5.2.5
 */
public class CompareDTvsDBFromFolder {

    // ====== FOLDERS ======
    private static final Path INPUT_DIR  = Paths.get("C:/data/in");   // <--- change
    private static final Path OUTPUT_DIR = Paths.get("C:/data/out");  // <--- change

    // ====== FILE DISCOVERY ======
    // Option A: choose the latest *.xlsx containing this keyword (case-insensitive)
    private static final String DT_KEYWORD = "DT";     // e.g., "DT", "DT_Span"
    private static final String DB_KEYWORD = "DUMP";   // e.g., "DB", "Dump", "Database"

    // Option B: exact filenames (leave "" to disable exact matching)
    private static final String DT_EXACT_FILENAME = ""; // e.g., "DT_Span_20250827.xlsx"
    private static final String DB_EXACT_FILENAME = ""; // e.g., "Database_Dump_20250827.xlsx"

    // ====== BEHAVIOR ======
    private static final boolean REQUIRE_DB_MOD3_MOD4_BLANK = false; // Stage-3: only match DB rows whose Mod3/Mod4 are blank

    private static final String OUTPUT_FILENAME = "Differences Record.xlsx";
    private static final String OUTPUT_SHEET    = "Differences";

    private static final DateTimeFormatter OUT_DTF = DateTimeFormatter.ofPattern("MM/dd/yyyy");
    private static final List<DateTimeFormatter> IN_DTFS = List.of(
            DateTimeFormatter.ofPattern("M/d/yyyy"),
            DateTimeFormatter.ofPattern("MM/dd/yyyy"),
            DateTimeFormatter.ofPattern("yyyy-MM-dd"),
            DateTimeFormatter.ofPattern("M/d/yy"),
            DateTimeFormatter.ofPattern("MM/dd/yy")
    );

    public static void main(String[] args) throws Exception {
        Files.createDirectories(INPUT_DIR);
        Files.createDirectories(OUTPUT_DIR);

        Path dtPath = DT_EXACT_FILENAME.isBlank()
                ? latestXlsxByKeyword(INPUT_DIR, DT_KEYWORD)
                : INPUT_DIR.resolve(DT_EXACT_FILENAME);

        Path dbPath = DB_EXACT_FILENAME.isBlank()
                ? latestXlsxByKeyword(INPUT_DIR, DB_KEYWORD)
                : INPUT_DIR.resolve(DB_EXACT_FILENAME);

        if (dtPath == null) throw new IllegalStateException("DT file not found in " + INPUT_DIR + " (keyword=" + DT_KEYWORD + ").");
        if (dbPath == null) throw new IllegalStateException("DB dump file not found in " + INPUT_DIR + " (keyword=" + DB_KEYWORD + ").");

        System.out.println("DT file: " + dtPath);
        System.out.println("DB file: " + dbPath);

        try (Workbook dtWb = new XSSFWorkbook(Files.newInputStream(dtPath));
             Workbook dbWb = new XSSFWorkbook(Files.newInputStream(dbPath))) {

            Sheet dtSheet = dtWb.getSheetAt(0);
            Sheet dbSheet = dbWb.getSheetAt(0);

            System.out.println("Indexing DB dump ...");
            DbIndex db = buildDbIndex(dbSheet);

            Path outPath = OUTPUT_DIR.resolve(OUTPUT_FILENAME);
            System.out.println("Comparing DT vs DB and writing: " + outPath);

            writeDifferences(dtSheet, db, outPath);

            System.out.println("Done.");
        }
    }

    // ---------- file discovery ----------
    private static Path latestXlsxByKeyword(Path dir, String keyword) throws IOException {
        final String kw = keyword == null ? "" : keyword.toLowerCase(Locale.ROOT);
        Path[] best = new Path[1];
        FileTime[] bestTime = new FileTime[1];

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, "*.xlsx")) {
            for (Path p : stream) {
                String name = p.getFileName().toString().toLowerCase(Locale.ROOT);
                if (!kw.isBlank() && !name.contains(kw)) continue;

                BasicFileAttributes attrs = Files.readAttributes(p, BasicFileAttributes.class);
                if (best[0] == null || attrs.lastModifiedTime().compareTo(bestTime[0]) > 0) {
                    best[0] = p;
                    bestTime[0] = attrs.lastModifiedTime();
                }
            }
        }
        return best[0];
    }

    // ---------- data structures ----------
    private record ExactKey(String proc, String mod, String mod2, LocalDate eff, LocalDate term, String rate4dp) { }
    private record PartialKey(String proc, String mod, String mod2, LocalDate term, String rate4dp) { }
    private record TripleKey(String proc, String mod, String mod2) { }

    private static class DbIndex {
        final Set<ExactKey> exact = new HashSet<>();
        final Set<PartialKey> partial = new HashSet<>();
        final Set<TripleKey> triplets = new HashSet<>();
    }

    private static DbIndex buildDbIndex(Sheet dbSheet) {
        DataFormatter fmt = new DataFormatter();
        Map<String,Integer> col = headerMap(dbSheet.getRow(dbSheet.getFirstRowNum()), fmt);

        String[] needed = {"Procedure Code","Modifier","Modifier 2","Modifier 3","Modifier 4","Effective","Termination","Allowed"};
        for (String n: needed) ensure(col, n, "DB dump");

        DbIndex idx = new DbIndex();

        for (int r = dbSheet.getFirstRowNum()+1; r <= dbSheet.getLastRowNum(); r++) {
            Row row = dbSheet.getRow(r);
            if (row == null) continue;

            String proc = norm(fmt.formatCellValue(getCell(row, col,"Procedure Code")));
            if (proc.isEmpty()) continue;

            String mod  = norm(fmt.formatCellValue(getCell(row, col,"Modifier")));
            String mod2 = norm(fmt.formatCellValue(getCell(row, col,"Modifier 2")));
            String mod3 = norm(fmt.formatCellValue(getCell(row, col,"Modifier 3")));
            String mod4 = norm(fmt.formatCellValue(getCell(row, col,"Modifier 4")));
            LocalDate eff  = parseDate(fmt.formatCellValue(getCell(row, col,"Effective")));
            LocalDate term = parseDate(fmt.formatCellValue(getCell(row, col,"Termination")));
            String rate4  = rateTo4(fmt.formatCellValue(getCell(row, col,"Allowed")));

            idx.exact.add(new ExactKey(proc, mod, mod2, eff, term, rate4));
            idx.partial.add(new PartialKey(proc, mod, mod2, term, rate4));

            if (REQUIRE_DB_MOD3_MOD4_BLANK) {
                if (mod3.isEmpty() && mod4.isEmpty())
                    idx.triplets.add(new TripleKey(proc, mod, mod2));
            } else {
                idx.triplets.add(new TripleKey(proc, mod, mod2));
            }
        }
        return idx;
    }

    private static void writeDifferences(Sheet dtSheet, DbIndex db, Path outPath) throws IOException {
        DataFormatter fmt = new DataFormatter();
        Map<String,Integer> col = headerMap(dtSheet.getRow(dtSheet.getFirstRowNum()), fmt);

        String[] needed = {"PROC","MOD","MOD2","Start Date","End Date","Rate"};
        for (String n: needed) ensure(col, n, "DT file");

        try (SXSSFWorkbook outWb = new SXSSFWorkbook(1000)) {
            outWb.setCompressTempFiles(true);
            SXSSFSheet outSh = outWb.createSheet(OUTPUT_SHEET);

            int wr = 0;
            Row h = outSh.createRow(wr++);
            write(h, 0, "Procedure code");
            write(h, 1, "Mod");
            write(h, 2, "Mod 1");
            write(h, 3, "Mod2");
            write(h, 4, "Mod3");
            write(h, 5, "Mod 4");
            write(h, 6, "Effective Date");
            write(h, 7, "Termination Date");
            write(h, 8, "Pricing Method");
            write(h, 9, "New Rate");
            write(h,10, "Old Rate");
            write(h,11, "Comments");

            for (int r = dtSheet.getFirstRowNum()+1; r <= dtSheet.getLastRowNum(); r++) {
                Row row = dtSheet.getRow(r);
                if (row == null) continue;

                String proc = norm(fmt.formatCellValue(getCell(row, col,"PROC")));
                if (proc.isEmpty()) continue;

                String mod  = norm(fmt.formatCellValue(getCell(row, col,"MOD")));
                String mod2 = norm(fmt.formatCellValue(getCell(row, col,"MOD2")));
                LocalDate start = parseDate(fmt.formatCellValue(getCell(row, col,"Start Date")));
                LocalDate end   = parseDate(fmt.formatCellValue(getCell(row, col,"End Date")));
                String rate4    = rateTo4(fmt.formatCellValue(getCell(row, col,"Rate")));

                // Stage 1: exact match -> ignore
                if (db.exact.contains(new ExactKey(proc, mod, mod2, start, end, rate4))) continue;
                // Stage 2: partial match -> ignore
                if (db.partial.contains(new PartialKey(proc, mod, mod2, end, rate4))) continue;
                // Stage 3: triplet missing -> New Code
                if (!db.triplets.contains(new TripleKey(proc, mod, mod2))) {
                    Row out = outSh.createRow(wr++);
                    int c = 0;
                    write(out, c++, proc);
                    write(out, c++, mod);
                    write(out, c++, mod2);          // Mod 1 from DT.MOD2
                    write(out, c++, "");            // Mod2 (blank)
                    write(out, c++, "");            // Mod3 (blank)
                    write(out, c++, "");            // Mod 4 (blank)
                    write(out, c++, fmtDate(start));// Effective
                    write(out, c++, fmtDate(end));  // Termination
                    write(out, c++, "Allowed");     // Pricing Method (as requested mapping)
                    write(out, c++, rate4);         // New Rate (DT Rate)
                    write(out, c++, "N/A");         // Old Rate
                    write(out, c++, "New Code");    // Comments
                }
            }

            for (int c = 0; c <= 11; c++) outSh.trackColumnForAutoSizing(c);
            for (int c = 0; c <= 11; c++) outSh.autoSizeColumn(c);

            try (OutputStream os = Files.newOutputStream(outPath)) {
                outWb.write(os);
            }
            outWb.dispose();
        }
    }

    // ---------- helpers ----------
    private static Map<String,Integer> headerMap(Row header, DataFormatter fmt) {
        if (header == null) throw new IllegalArgumentException("Missing header row.");
        Map<String,Integer> map = new HashMap<>();
        for (int c = header.getFirstCellNum(); c < header.getLastCellNum(); c++) {
            Cell cell = header.getCell(c);
            String key = cell == null ? "" : fmt.formatCellValue(cell).trim();
            if (!key.isEmpty()) map.put(key.toUpperCase(Locale.ROOT), c);
        }
        return map;
    }

    private static void ensure(Map<String,Integer> col, String name, String where) {
        if (!col.containsKey(name.toUpperCase(Locale.ROOT)))
            throw new IllegalArgumentException("Expected column \"" + name + "\" in " + where + " header.");
    }

    private static Cell getCell(Row row, Map<String,Integer> col, String name) {
        Integer idx = col.get(name.toUpperCase(Locale.ROOT));
        return (idx == null) ? null : row.getCell(idx, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL);
    }

    private static String norm(String s) {
        if (s == null) return "";
        s = s.trim();
        if (s.equalsIgnoreCase("null")) return "";
        return s.toUpperCase(Locale.ROOT);
    }

    private static LocalDate parseDate(String s) {
        s = s == null ? "" : s.trim();
        if (s.isEmpty()) return null;
        for (DateTimeFormatter f: IN_DTFS) {
            try { return LocalDate.parse(s, f); } catch (DateTimeParseException ignored) {}
        }
        try {
            double serial = Double.parseDouble(s);
            return LocalDate.of(1899,12,30).plusDays((long)serial);
        } catch (Exception ignored) {}
        return null;
    }

    private static String fmtDate(LocalDate d) {
        return d == null ? "" : OUT_DTF.format(d);
    }

    private static String rateTo4(String raw) {
        String s = raw == null ? "" : raw.trim();
        if (s.isEmpty()) return "0.0000";
        s = s.replace("$","").replace(",","");
        try {
            BigDecimal bd = new BigDecimal(s);
            return bd.setScale(4, BigDecimal.ROUND_HALF_UP).toPlainString();
        } catch (NumberFormatException e) {
            return "0.0000";
        }
    }

    private static void write(Row r, int c, String v) {
        Cell cell = r.createCell(c, CellType.STRING);
        cell.setCellValue(v == null ? "" : v);
    }
}

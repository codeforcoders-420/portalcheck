import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.apache.poi.xssf.streaming.SXSSFSheet;

import java.io.*;
import java.math.BigDecimal;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;

/**
 * Compares DT file vs DB dump and writes differences to:
 *   <OUTPUT_DIR>/Differences Record.xlsx   (sheet: Differences)
 *
 * Rules (in order):
 *   A) Ignore "Exact":  PROC+MOD+MOD2+Start+End+Rate == Procedure+Modifier+Modifier2+Effective+Termination+Allowed
 *   B) Ignore "Partial": PROC+MOD+MOD2+End+Rate == Procedure+Modifier+Modifier2+Termination+Allowed
 *   C) If triplet (PROC,MOD,MOD2) exists in DB:
 *        - Pick best DB period for that triplet.
 *        - If Rate != Allowed (4dp-normalized) -> write "Rate change".
 *      Else:
 *        - Write "New Code".
 *
 * HOW TO USE:
 *  1) Set INPUT_DIR and OUTPUT_DIR below.
 *  2) EITHER set keywords (DT_KEYWORD/DB_KEYWORD) -> program picks latest matching .xlsx,
 *     OR set exact filenames (DT_EXACT_FILENAME/DB_EXACT_FILENAME).
 *
 * Maven deps:
 *   org.apache.poi:poi-ooxml:5.2.5
 *   org.apache.poi:poi:5.2.5
 */
public class CompareDTvsDB_Complete {

    // ====== FOLDERS ======
    private static final Path INPUT_DIR  = Paths.get("C:/data/in");   // <--- change for your environment
    private static final Path OUTPUT_DIR = Paths.get("C:/data/out");  // <--- change for your environment

    // ====== FILE DISCOVERY ======
    // Option A: choose the latest *.xlsx containing this keyword (case-insensitive)
    private static final String DT_KEYWORD = "DT";     // e.g., "DT", "DT_Span"
    private static final String DB_KEYWORD = "DUMP";   // e.g., "DB", "Dump", "Database"

    // Option B: exact filenames (leave "" to disable exact matching)
    private static final String DT_EXACT_FILENAME = ""; // e.g., "DT_Span_20250827.xlsx"
    private static final String DB_EXACT_FILENAME = ""; // e.g., "Database_Dump_20250827.xlsx"

    // ====== BEHAVIOR SWITCHES ======
    // Stage-3 triplet existence: if true, only consider DB rows with blank Mod3 & Mod4 as "existing"
    private static final boolean REQUIRE_DB_MOD3_MOD4_BLANK = false;

    private static final String OUTPUT_FILENAME = "Differences Record.xlsx";
    private static final String OUTPUT_SHEET    = "Differences";

    private static final DateTimeFormatter OUT_DTF = DateTimeFormatter.ofPattern("MM/dd/yyyy");
    private static final List<DateTimeFormatter> IN_DTFS = List.of(
            DateTimeFormatter.ofPattern("M/d/yyyy"),
            DateTimeFormatter.ofPattern("MM/dd/yyyy"),
            DateTimeFormatter.ofPattern("yyyy-MM-dd"),
            DateTimeFormatter.ofPattern("M/d/yy"),
            DateTimeFormatter.ofPattern("MM/dd/yy")
    );

    public static void main(String[] args) throws Exception {
        Files.createDirectories(INPUT_DIR);
        Files.createDirectories(OUTPUT_DIR);

        Path dtPath = DT_EXACT_FILENAME.isBlank()
                ? latestXlsxByKeyword(INPUT_DIR, DT_KEYWORD)
                : INPUT_DIR.resolve(DT_EXACT_FILENAME);

        Path dbPath = DB_EXACT_FILENAME.isBlank()
                ? latestXlsxByKeyword(INPUT_DIR, DB_KEYWORD)
                : INPUT_DIR.resolve(DB_EXACT_FILENAME);

        if (dtPath == null) throw new IllegalStateException("DT file not found in " + INPUT_DIR + " (keyword=" + DT_KEYWORD + ").");
        if (dbPath == null) throw new IllegalStateException("DB dump file not found in " + INPUT_DIR + " (keyword=" + DB_KEYWORD + ").");

        System.out.println("DT file: " + dtPath);
        System.out.println("DB file: " + dbPath);

        try (Workbook dtWb = new XSSFWorkbook(Files.newInputStream(dtPath));
             Workbook dbWb = new XSSFWorkbook(Files.newInputStream(dbPath))) {

            Sheet dtSheet = dtWb.getSheetAt(0); // use first sheet; change to getSheet("...") if needed
            Sheet dbSheet = dbWb.getSheetAt(0);

            System.out.println("Indexing DB dump ...");
            DbIndex db = buildDbIndex(dbSheet);

            Path outPath = OUTPUT_DIR.resolve(OUTPUT_FILENAME);
            System.out.println("Comparing DT vs DB and writing: " + outPath);

            writeDifferences(dtSheet, db, outPath);

            System.out.println("Done.");
        }
    }

    // ---------- file discovery ----------
    private static Path latestXlsxByKeyword(Path dir, String keyword) throws IOException {
        final String kw = keyword == null ? "" : keyword.toLowerCase(Locale.ROOT);
        Path best = null;
        FileTime bestTime = null;

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, "*.xlsx")) {
            for (Path p : stream) {
                String name = p.getFileName().toString().toLowerCase(Locale.ROOT);
                if (!kw.isBlank() && !name.contains(kw)) continue;

                BasicFileAttributes attrs = Files.readAttributes(p, BasicFileAttributes.class);
                if (best == null || attrs.lastModifiedTime().compareTo(bestTime) > 0) {
                    best = p;
                    bestTime = attrs.lastModifiedTime();
                }
            }
        }
        return best;
    }

    // ---------- data structures ----------
    private record ExactKey(String proc, String mod, String mod2, LocalDate eff, LocalDate term, String rate4dp) { }
    private record PartialKey(String proc, String mod, String mod2, LocalDate term, String rate4dp) { }
    private record TripleKey(String proc, String mod, String mod2) { }

    private static class DbRow {
        String proc, mod, mod2, mod3, mod4, allowed4;
        LocalDate eff, term;
    }

    private static class DbIndex {
        final Set<ExactKey> exact = new HashSet<>();
        final Set<PartialKey> partial = new HashSet<>();
        final Set<TripleKey> triplets = new HashSet<>();
        final Map<TripleKey, List<DbRow>> byTriplet = new HashMap<>();
    }

    // ---------- DB indexing ----------
    private static DbIndex buildDbIndex(Sheet dbSheet) {
        DataFormatter fmt = new DataFormatter();
        Map<String,Integer> col = headerMap(dbSheet.getRow(dbSheet.getFirstRowNum()), fmt);

        String[] needed = {"Procedure Code","Modifier","Modifier 2","Modifier 3","Modifier 4","Effective","Termination","Allowed"};
        for (String n: needed) ensure(col, n, "DB dump");

        DbIndex idx = new DbIndex();

        for (int r = dbSheet.getFirstRowNum()+1; r <= dbSheet.getLastRowNum(); r++) {
            Row row = dbSheet.getRow(r);
            if (row == null) continue;

            String proc = norm(fmt.formatCellValue(getCell(row, col,"Procedure Code")));
            if (proc.isEmpty()) continue;

            String mod  = norm(fmt.formatCellValue(getCell(row, col,"Modifier")));
            String mod2 = norm(fmt.formatCellValue(getCell(row, col,"Modifier 2")));
            String mod3 = norm(fmt.formatCellValue(getCell(row, col,"Modifier 3")));
            String mod4 = norm(fmt.formatCellValue(getCell(row, col,"Modifier 4")));
            LocalDate eff  = parseDate(fmt.formatCellValue(getCell(row, col,"Effective")));
            LocalDate term = parseDate(fmt.formatCellValue(getCell(row, col,"Termination")));
            String rate4  = rateTo4(fmt.formatCellValue(getCell(row, col,"Allowed")));

            // sets for fast ignore checks
            idx.exact.add(new ExactKey(proc, mod, mod2, eff, term, rate4));
            idx.partial.add(new PartialKey(proc, mod, mod2, term, rate4));

            // triplet existence
            if (REQUIRE_DB_MOD3_MOD4_BLANK) {
                if (mod3.isEmpty() && mod4.isEmpty())
                    idx.triplets.add(new TripleKey(proc, mod, mod2));
            } else {
                idx.triplets.add(new TripleKey(proc, mod, mod2));
            }

            // store full row for best-match / rate comparison
            DbRow dr = new DbRow();
            dr.proc = proc; dr.mod = mod; dr.mod2 = mod2; dr.mod3 = mod3; dr.mod4 = mod4;
            dr.eff = eff; dr.term = term; dr.allowed4 = rate4;

            idx.byTriplet.computeIfAbsent(new TripleKey(proc, mod, mod2), k -> new ArrayList<>()).add(dr);
        }
        return idx;
    }

    // ---------- write differences ----------
    private static void writeDifferences(Sheet dtSheet, DbIndex db, Path outPath) throws IOException {
        DataFormatter fmt = new DataFormatter();
        Map<String,Integer> col = headerMap(dtSheet.getRow(dtSheet.getFirstRowNum()), fmt);

        String[] needed = {"PROC","MOD","MOD2","Start Date","End Date","Rate"};
        for (String n: needed) ensure(col, n, "DT file");

        try (SXSSFWorkbook outWb = new SXSSFWorkbook(1000)) {
            outWb.setCompressTempFiles(true);
            SXSSFSheet outSh = outWb.createSheet(OUTPUT_SHEET);

            int wr = 0;
            Row h = outSh.createRow(wr++);
            write(h, 0, "Procedure code");
            write(h, 1, "Mod");
            write(h, 2, "Mod 1");
            write(h, 3, "Mod2");
            write(h, 4, "Mod3");
            write(h, 5, "Mod 4");
            write(h, 6, "Effective Date");
            write(h, 7, "Termination Date");
            write(h, 8, "Pricing Method");
            write(h, 9, "New Rate");
            write(h,10, "Old Rate");
            write(h,11, "Comments");

            for (int r = dtSheet.getFirstRowNum()+1; r <= dtSheet.getLastRowNum(); r++) {
                Row row = dtSheet.getRow(r);
                if (row == null) continue;

                String proc = norm(fmt.formatCellValue(getCell(row, col,"PROC")));
                if (proc.isEmpty()) continue; // skip blank rows

                String mod  = norm(fmt.formatCellValue(getCell(row, col,"MOD")));
                String mod2 = norm(fmt.formatCellValue(getCell(row, col,"MOD2")));
                LocalDate start = parseDate(fmt.formatCellValue(getCell(row, col,"Start Date")));
                LocalDate end   = parseDate(fmt.formatCellValue(getCell(row, col,"End Date")));
                String rate4    = rateTo4(fmt.formatCellValue(getCell(row, col,"Rate")));

                // A) Exact ignore
                if (db.exact.contains(new ExactKey(proc, mod, mod2, start, end, rate4))) continue;

                // B) Partial ignore
                if (db.partial.contains(new PartialKey(proc, mod, mod2, end, rate4))) continue;

                // C) Triplet present?
                TripleKey trip = new TripleKey(proc, mod, mod2);
                List<DbRow> candidates = db.byTriplet.get(trip);

                if (candidates == null || candidates.isEmpty()) {
                    // ---- NEW CODE ----
                    Row out = outSh.createRow(wr++);
                    int c = 0;
                    write(out, c++, proc);
                    write(out, c++, mod);
                    write(out, c++, mod2);           // Mod 1 from DT.MOD2
                    write(out, c++, "");             // Mod2
                    write(out, c++, "");             // Mod3
                    write(out, c++, "");             // Mod 4
                    write(out, c++, fmtDate(start)); // Effective
                    write(out, c++, fmtDate(end));   // Termination
                    write(out, c++, "Allowed");      // Pricing Method
                    write(out, c++, rate4);          // New Rate
                    write(out, c++, "N/A");          // Old Rate
                    write(out, c++, "New Code");     // Comments
                    continue;
                }

                // ---- RATE CHANGE detection for existing triplet ----
                DbRow best = pickBest(candidates, start, end);
                if (best != null && !rate4.equals(best.allowed4)) {
                    Row out = outSh.createRow(wr++);
                    int c = 0;
                    write(out, c++, proc);
                    write(out, c++, mod);
                    write(out, c++, mod2);            // Mod 1
                    write(out, c++, "");              // Mod2
                    write(out, c++, "");              // Mod3
                    write(out, c++, "");              // Mod 4
                    write(out, c++, fmtDate(start));  // Effective Date (DT)
                    write(out, c++, fmtDate(end));    // Termination Date (DT)
                    write(out, c++, "Allowed");       // Pricing Method
                    write(out, c++, rate4);           // New Rate (DT)
                    write(out, c++, best.allowed4);   // Old Rate (DB)
                    write(out, c++, "Rate change");   // Comments
                }
                // else: same rate as best DB row → nothing to write
            }

            // Tidy columns (cheap autosize)
            for (int c = 0; c <= 11; c++) outSh.trackColumnForAutoSizing(c);
            for (int c = 0; c <= 11; c++) outSh.autoSizeColumn(c);

            try (OutputStream os = Files.newOutputStream(outPath)) {
                outWb.write(os);
            }
            outWb.dispose();
        }
    }

    // ---------- best-match picking ----------
    private static boolean overlaps(LocalDate aStart, LocalDate aEnd, LocalDate bStart, LocalDate bEnd) {
        if (aStart == null || aEnd == null || bStart == null || bEnd == null) return false;
        return !aStart.isAfter(bEnd) && !bStart.isAfter(aEnd);
    }

    /**
     * Choose the most relevant DB row for a given DT period:
     *  1) Prefer rows whose period overlaps DT period; among them, prefer latest eff <= DT.start.
     *  2) If none overlap: choose the row with the nearest eff prior to DT.start.
     *  3) Else: choose earliest future eff.
     */
    private static DbRow pickBest(List<DbRow> rows, LocalDate dStart, LocalDate dEnd) {
        if (rows == null || rows.isEmpty()) return null;

        List<DbRow> overlapping = new ArrayList<>();
        for (DbRow r : rows) {
            if (overlaps(dStart, dEnd, r.eff, r.term)) overlapping.add(r);
        }
        if (!overlapping.isEmpty()) {
            overlapping.sort(Comparator
                    .comparing((DbRow r) -> r.eff == null ? LocalDate.MIN : r.eff)
                    .reversed());
            for (DbRow r : overlapping) {
                if (r.eff == null || !r.eff.isAfter(dStart)) return r;
            }
            return overlapping.get(0);
        }

        DbRow prior = null;
        for (DbRow r : rows) {
            if (r.eff != null && !r.eff.isAfter(dStart)) {
                if (prior == null || r.eff.isAfter(prior.eff)) prior = r;
            }
        }
        if (prior != null) return prior;

        rows.sort(Comparator.comparing(r -> r.eff == null ? LocalDate.MAX : r.eff));
        return rows.get(0);
    }

    // ---------- common helpers ----------
    private static Map<String,Integer> headerMap(Row header, DataFormatter fmt) {
        if (header == null) throw new IllegalArgumentException("Missing header row.");
        Map<String,Integer> map = new HashMap<>();
        for (int c = header.getFirstCellNum(); c < header.getLastCellNum(); c++) {
            Cell cell = header.getCell(c);
            String key = cell == null ? "" : fmt.formatCellValue(cell).trim();
            if (!key.isEmpty()) map.put(key.toUpperCase(Locale.ROOT), c);
        }
        return map;
    }

    private static void ensure(Map<String,Integer> col, String name, String where) {
        if (!col.containsKey(name.toUpperCase(Locale.ROOT)))
            throw new IllegalArgumentException("Expected column \"" + name + "\" in " + where + " header.");
    }

    private static Cell getCell(Row row, Map<String,Integer> col, String name) {
        Integer idx = col.get(name.toUpperCase(Locale.ROOT));
        return (idx == null) ? null : row.getCell(idx, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL);
    }

    private static String norm(String s) {
        if (s == null) return "";
        s = s.trim();
        if (s.equalsIgnoreCase("null")) return "";
        return s.toUpperCase(Locale.ROOT);
    }

    private static LocalDate parseDate(String s) {
        s = s == null ? "" : s.trim();
        if (s.isEmpty()) return null;
        for (DateTimeFormatter f: IN_DTFS) {
            try { return LocalDate.parse(s, f); } catch (DateTimeParseException ignored) {}
        }
        try {
            double serial = Double.parseDouble(s);
            return LocalDate.of(1899,12,30).plusDays((long)serial);
        } catch (Exception ignored) {}
        return null;
    }

    private static String fmtDate(LocalDate d) {
        return d == null ? "" : OUT_DTF.format(d);
    }

    private static String rateTo4(String raw) {
        String s = raw == null ? "" : raw.trim();
        if (s.isEmpty()) return "0.0000";
        s = s.replace("$","").replace(",","");
        try {
            BigDecimal bd = new BigDecimal(s);
            return bd.setScale(4, BigDecimal.ROUND_HALF_UP).toPlainString();
        } catch (NumberFormatException e) {
            return "0.0000";
        }
    }

    private static void write(Row r, int c, String v) {
        Cell cell = r.createCell(c, CellType.STRING);
        cell.setCellValue(v == null ? "" : v);
    }
}

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class RbrvZipComparator {

    // Adjust your environment JDBC URLs and DB name here.
    // These assume Windows Integrated Security.
    private static final Map<Environment, String> CONNECTION_URLS = Map.of(
            Environment.DEV,  "jdbc:sqlserver://DEV-SERVER;databaseName=RBRVS;integratedSecurity=true;encrypt=false",
            Environment.SIT,  "jdbc:sqlserver://SIT-SERVER;databaseName=RBRVS;integratedSecurity=true;encrypt=false",
            Environment.UAT,  "jdbc:sqlserver://UAT-SERVER;databaseName=RBRVS;integratedSecurity=true;encrypt=false",
            Environment.PROD, "jdbc:sqlserver://PROD-SERVER;databaseName=RBRVS;integratedSecurity=true;encrypt=false"
    );

    private static final String QUERY =
            "SELECT Year, Eff, Term, Carrier_no, Locality_no, Zip_Low, Zip_High, RVS_ID " +
            "FROM RBRV_ZIP WHERE Year = ?";

    private static final int TARGET_YEAR = 2025;

    // Where to place the Excel files (change if you want a specific folder)
    private static final Path OUTPUT_DIR = Path.of("."); // current directory

    // Timestamp format for file name: ddMMyyyyHHmmss
    private static final DateTimeFormatter FILE_TS_FORMAT =
            DateTimeFormatter.ofPattern("ddMMyyyyHHmmss");

    public static void main(String[] args) {
        try {
            // 1) Load DEV as reference (source)
            Environment sourceEnv = Environment.DEV;
            Set<RecordKey> devData = loadEnvironmentData(sourceEnv);

            // 2) Compare DEV vs each target env and create separate Excel for each
            for (Environment targetEnv : List.of(Environment.SIT, Environment.UAT, Environment.PROD)) {
                Set<RecordKey> targetData = loadEnvironmentData(targetEnv);
                List<DifferenceRow> diffs = compare(devData, targetData, targetEnv);

                // Generate file name: Zipdata_<Source>_<Dest>_ddMMyyyyHHmmss.xlsx
                String timestamp = LocalDateTime.now().format(FILE_TS_FORMAT);
                String fileName = "Zipdata_" + sourceEnv + "_" + targetEnv + "_" + timestamp + ".xlsx";
                Path outputPath = OUTPUT_DIR.resolve(fileName);

                writeDifferencesToExcel(sourceEnv, targetEnv, diffs, outputPath);

                System.out.println("Created Excel for " + sourceEnv + " â†’ " + targetEnv +
                        ": " + outputPath.toAbsolutePath());
            }

            System.out.println("All comparisons completed.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // ---- DATA STRUCTURES ----

    /**
     * Key is ALL columns: Year, Eff, Term, Carrier_no, Locality_no, Zip_Low, Zip_High, RVS_ID
     */
    public record RecordKey(
            int year,
            LocalDate eff,
            LocalDate term,
            String carrierNo,
            String localityNo,
            String zipLow,
            String zipHigh,
            String rvsId
    ) {}

    public enum DifferenceType {
        MISSING_IN_ENV, // Present in DEV (source), missing in target env
        NEW_IN_ENV      // Present in target env, missing in DEV (source)
    }

    public enum Environment {
        DEV, SIT, UAT, PROD
    }

    public record DifferenceRow(
            Environment environment,    // target env (SIT/UAT/PROD)
            DifferenceType differenceType,
            RecordKey key
    ) {}

    // ---- DB LOADING ----

    /**
     * Loads all rows for the given environment for the target year and stores them
     * as a Set<RecordKey> where RecordKey contains all columns (including RVS_ID).
     */
    private static Set<RecordKey> loadEnvironmentData(Environment env) throws SQLException {
        String url = CONNECTION_URLS.get(env);
        if (url == null) {
            throw new IllegalArgumentException("No connection URL configured for environment: " + env);
        }

        System.out.println("Loading data for environment: " + env);

        try (Connection conn = DriverManager.getConnection(url);
             PreparedStatement ps = conn.prepareStatement(QUERY)) {

            ps.setInt(1, TARGET_YEAR);

            try (ResultSet rs = ps.executeQuery()) {
                Set<RecordKey> result = new HashSet<>();

                while (rs.next()) {
                    int year = rs.getInt("Year");
                    LocalDate eff = toLocalDate(rs.getDate("Eff"));
                    LocalDate term = toLocalDate(rs.getDate("Term"));
                    String carrier = rs.getString("Carrier_no");
                    String locality = rs.getString("Locality_no");
                    String zipLow = rs.getString("Zip_Low");
                    String zipHigh = rs.getString("Zip_High");
                    String rvsId = rs.getString("RVS_ID");

                    RecordKey key = new RecordKey(year, eff, term, carrier, locality, zipLow, zipHigh, rvsId);
                    result.add(key); // Set ensures uniqueness of full row
                }

                System.out.println("Loaded " + result.size() + " row(s) for " + env);
                return result;
            }
        }
    }

    private static LocalDate toLocalDate(Date date) {
        return (date == null) ? null : date.toLocalDate();
    }

    // ---- COMPARISON LOGIC ----

    /**
     * Compares DEV (source) vs env (target) using full-row key:
     *  - Row in DEV but not in env => MISSING_IN_ENV
     *  - Row in env but not in DEV => NEW_IN_ENV
     */
    private static List<DifferenceRow> compare(Set<RecordKey> devData,
                                               Set<RecordKey> envData,
                                               Environment env) {

        List<DifferenceRow> differences = new ArrayList<>();

        // 1) In DEV but not in env -> MISSING_IN_ENV
        for (RecordKey key : devData) {
            if (!envData.contains(key)) {
                differences.add(new DifferenceRow(env, DifferenceType.MISSING_IN_ENV, key));
            }
        }

        // 2) In env but not in DEV -> NEW_IN_ENV
        for (RecordKey key : envData) {
            if (!devData.contains(key)) {
                differences.add(new DifferenceRow(env, DifferenceType.NEW_IN_ENV, key));
            }
        }

        System.out.println("Found " + differences.size() + " difference(s) for " + env);
        return differences;
    }

    // ---- EXCEL OUTPUT (one file per env) ----

    private static void writeDifferencesToExcel(Environment sourceEnv,
                                                Environment targetEnv,
                                                List<DifferenceRow> diffs,
                                                Path outputPath) throws IOException {

        try (XSSFWorkbook workbook = new XSSFWorkbook()) {

            // Single sheet per file, named after target env
            Sheet sheet = workbook.createSheet(targetEnv.name());

            // Header
            Row header = sheet.createRow(0);
            int col = 0;
            header.createCell(col++).setCellValue("Source_Env");
            header.createCell(col++).setCellValue("Target_Env");
            header.createCell(col++).setCellValue("Difference_Type");
            header.createCell(col++).setCellValue("Year");
            header.createCell(col++).setCellValue("Eff");
            header.createCell(col++).setCellValue("Term");
            header.createCell(col++).setCellValue("Carrier_no");
            header.createCell(col++).setCellValue("Locality_no");
            header.createCell(col++).setCellValue("Zip_Low");
            header.createCell(col++).setCellValue("Zip_High");
            header.createCell(col++).setCellValue("RVS_ID");

            // Data rows
            int rowIndex = 1;
            for (DifferenceRow diff : diffs) {
                Row row = sheet.createRow(rowIndex++);
                col = 0;

                RecordKey k = diff.key();

                setCell(row, col++, sourceEnv.name());
                setCell(row, col++, targetEnv.name());
                setCell(row, col++, diff.differenceType().name());
                setCell(row, col++, k.year());
                setCell(row, col++, k.eff());
                setCell(row, col++, k.term());
                setCell(row, col++, k.carrierNo());
                setCell(row, col++, k.localityNo());
                setCell(row, col++, k.zipLow());
                setCell(row, col++, k.zipHigh());
                setCell(row, col++, k.rvsId());
            }

            // Auto-size columns (optional; skip for very large data to save time)
            for (int c = 0; c < 11; c++) {
                sheet.autoSizeColumn(c);
            }

            // Ensure output directory exists
            Files.createDirectories(outputPath.getParent());

            try (var out = Files.newOutputStream(outputPath)) {
                workbook.write(out);
            }
        }
    }

    private static void setCell(Row row, int columnIndex, Object value) {
        Cell cell = row.createCell(columnIndex);
        if (value == null) {
            cell.setBlank();
        } else if (value instanceof Number n) {
            cell.setCellValue(n.doubleValue());
        } else if (value instanceof LocalDate d) {
            cell.setCellValue(d.toString());
        } else {
            cell.setCellValue(value.toString());
        }
    }
}

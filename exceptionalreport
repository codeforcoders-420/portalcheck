import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.streaming.SXSSFSheet;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * MultiQueryExcelExporter — Per-Key Mode
 * ------------------------------------------------------------
 * Java 17+ utility that:
 *  1) Reads 6 SQL queries from an Excel file (first sheet, cells A1..A6)
 *  2) Runs the 1st query to fetch ~1500+ distinct keys (exactly one-column)
 *  3) For each of the remaining 5 queries, executes the query **one key at a time**
 *     by binding the key anywhere the token ":FSID" (or {{KEY}}) appears.
 *  4) Streams *all* matching rows across all keys into a single sheet per query
 *     (Q2..Q6) and prefixes an extra column "Key" so you know which FSID
 *     produced each row.
 *
 *  This avoids giant IN-lists and temp tables, and strictly follows your
 *  "value-by-value" execution requirement.
 *
 *  Tokens supported in Query #2..#6:
 *    - :FSID               → replaced with JDBC parameter '?', bound to the key
 *    - {{KEY}}             → same behavior as :FSID (use either style)
 *    - You may include the token multiple times in one statement; all receive the
 *      same bound value (useful for self-joins filtering both a and b).
 *
 *  Output:
 *    - One workbook with 5 sheets: Q2..Q6
 *    - Each sheet contains a header row: [Key, <DB column labels...>]
 *    - Rows from all keys are appended; streaming keeps memory small.
 *
 * Requirements:
 *  - Microsoft SQL Server JDBC driver (mssql-jdbc)
 *  - Apache POI (poi-ooxml)
 *  - Windows Integrated Auth DLL available (mssql-jdbc_auth-*.dll) for SSPI
 */
public class MultiQueryExcelExporter {

    // --- Configure defaults here or via args/env ---
    private static final String DEFAULT_INPUT_XLSX = "./queries.xlsx"; // sheet0 A1..A6
    private static final String DEFAULT_OUTPUT_XLSX = "./results-" + nowStamp() + ".xlsx";

    // Windows Integrated Authentication (SSPI). Ensure sqljdbc_auth.dll is on PATH or -Djava.library.path
    private static final String JDBC_URL = System.getProperty("jdbc.url",
            "jdbc:sqlserver://localhost:1433;databaseName=YourDB;encrypt=true;trustServerCertificate=true;integratedSecurity=true");

    private static final int FETCH_SIZE = 10_000;

    // Token patterns
    private static final Pattern FSID_TOKEN = Pattern.compile(":FSID", Pattern.CASE_INSENSITIVE);
    private static final Pattern KEY_TOKEN  = Pattern.compile("\{\{KEY\}}", Pattern.CASE_INSENSITIVE);

    public static void main(String[] args) throws Exception {
        final Path inputPath = Paths.get(args.length > 0 ? args[0] : DEFAULT_INPUT_XLSX);
        final Path outputPath = Paths.get(args.length > 1 ? args[1] : DEFAULT_OUTPUT_XLSX);

        System.out.println("→ Input queries:  " + inputPath.toAbsolutePath());
        System.out.println("→ Output workbook: " + outputPath.toAbsolutePath());

        final List<String> queries = readSixQueries(inputPath);
        if (queries.size() < 6) {
            throw new IllegalStateException("Expected 6 queries in A1..A6 of the first sheet; got " + queries.size());
        }

        try (Connection conn = newConnection();
             SXSSFWorkbook wb = new SXSSFWorkbook(1000)) { // keep 1000 rows in memory per sheet

            wb.setCompressTempFiles(true);

            // 1) Run key query
            final String keyQuery = queries.get(0);
            final List<String> keys = fetchKeys(conn, keyQuery);
            System.out.println("✔ Key count: " + keys.size());

            // 2) Execute the remaining 5 queries per-key and append to sheets
            final Map<Integer, SheetWriter> writers = new LinkedHashMap<>();
            for (int i = 1; i <= 5; i++) {
                final String sheetName = "Q" + (i + 1);
                writers.put(i, new SheetWriter(wb.createSheet(sheetName)));
            }

            for (int qi = 1; qi <= 5; qi++) {
                final String raw = queries.get(qi);
                final PreparedQuery pq = preparePerKeyStatement(raw);
                final SheetWriter writer = writers.get(qi);

                System.out.println("→ Executing query " + (qi + 1) + " per-key into sheet '" + writer.sheet.getSheetName() + "' …");

                // Prepare the statement once (with the correct number of ?) and reuse it
                try (PreparedStatement ps = conn.prepareStatement(pq.sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
                    ps.setFetchSize(FETCH_SIZE);

                    boolean headerWritten = false;
                    long written = 0;

                    for (String key : keys) {
                        // Bind the key into all parameter positions
                        for (int p = 1; p <= pq.paramCount; p++) {
                            ps.setString(p, key == null ? null : key.trim());
                        }

                        try (ResultSet rs = ps.executeQuery()) {
                            if (!headerWritten) {
                                writer.writeHeader(rs.getMetaData());
                                headerWritten = true;
                            }
                            written += writer.appendRows(rs, key);
                        }
                    }

                    writer.autoSizeAllColumns();
                    System.out.println("   ✔ Rows written (Q" + (qi + 1) + "): " + written);
                }
            }

            // 3) Save workbook
            try (FileOutputStream fos = new FileOutputStream(outputPath.toFile())) {
                wb.write(fos);
            }
            System.out.println("✔ Done. Workbook saved: " + outputPath.toAbsolutePath());
        }
    }

    private static Connection newConnection() throws SQLException {
        // With integratedSecurity=true, the Microsoft JDBC driver uses your current Windows credentials.
        // Make sure the appropriate mssql-jdbc_auth-<arch>.dll is resolvable via PATH or -Djava.library.path.
        return DriverManager.getConnection(JDBC_URL);
    }

    // Reads A1..A6 from sheet 0 as SQL strings (empty cells are ignored)
    private static List<String> readSixQueries(Path xlsx) throws IOException {
        List<String> list = new ArrayList<>(6);
        try (FileInputStream fis = new FileInputStream(xlsx.toFile());
             Workbook wb = WorkbookFactory.create(fis)) {
            Sheet s = wb.getSheetAt(0);
            for (int r = 0; r < 6; r++) {
                Row row = s.getRow(r);
                if (row == null) continue;
                Cell c = row.getCell(0);
                if (c == null) continue;
                c.setCellType(CellType.STRING);
                String sql = c.getStringCellValue();
                if (sql != null && !sql.isBlank()) {
                    list.add(sql.trim());
                }
            }
        }
        return list;
    }

    // Executes the 1st query; expects exactly one column of keys (any type → String)
    private static List<String> fetchKeys(Connection conn, String keySql) throws SQLException {
        List<String> keys = new ArrayList<>(2048);
        try (Statement st = conn.createStatement();
             ResultSet rs = st.executeQuery(keySql)) {
            final ResultSetMetaData md = rs.getMetaData();
            if (md.getColumnCount() != 1) {
                throw new IllegalStateException("Key query must return exactly 1 column; got " + md.getColumnCount());
            }
            while (rs.next()) {
                Object val = rs.getObject(1);
                if (val != null) keys.add(val.toString());
            }
        }
        return keys;
    }

    // Prepare a per-key SQL with JDBC placeholders and a parameter count
    private static PreparedQuery preparePerKeyStatement(String raw) {
        String sql = raw;
        int count = 0;
        Matcher m1 = FSID_TOKEN.matcher(sql);
        StringBuffer sb = new StringBuffer();
        while (m1.find()) {
            m1.appendReplacement(sb, "?");
            count++;
        }
        m1.appendTail(sb);
        sql = sb.toString();

        Matcher m2 = KEY_TOKEN.matcher(sql);
        sb = new StringBuffer();
        while (m2.find()) {
            m2.appendReplacement(sb, "?");
            count++;
        }
        m2.appendTail(sb);
        sql = sb.toString();

        if (count == 0) {
            throw new IllegalArgumentException("Downstream query is missing :FSID or {{KEY}} token(s):
" + raw);
        }
        return new PreparedQuery(sql, count);
    }

    // Helper to stream into a sheet with an extra leading "Key" column
    private static final class SheetWriter {
        final SXSSFSheet sheet;
        int nextRow = 0;

        SheetWriter(SXSSFSheet sheet) {
            this.sheet = sheet;
            this.sheet.trackAllColumnsForAutoSizing();
        }

        void writeHeader(ResultSetMetaData md) throws SQLException {
            Row hdr = sheet.createRow(nextRow++);
            // First column is the Key used
            Cell keyCell = hdr.createCell(0, CellType.STRING);
            keyCell.setCellValue("Key");
            for (int c = 1; c <= md.getColumnCount(); c++) {
                Cell cell = hdr.createCell(c, CellType.STRING);
                cell.setCellValue(md.getColumnLabel(c));
            }
        }

        long appendRows(ResultSet rs, String key) throws SQLException {
            long count = 0;
            final int cols = rs.getMetaData().getColumnCount();
            while (rs.next()) {
                Row row = sheet.createRow(nextRow++);
                // write the key
                row.createCell(0, CellType.STRING).setCellValue(key == null ? "" : key);
                for (int c = 1; c <= cols; c++) {
                    Object val = rs.getObject(c);
                    Cell cell = row.createCell(c);
                    if (val == null) {
                        cell.setBlank();
                    } else if (val instanceof Number num) {
                        cell.setCellValue(num.doubleValue());
                    } else if (val instanceof java.sql.Date d) {
                        cell.setCellValue(d);
                    } else if (val instanceof java.sql.Timestamp ts) {
                        cell.setCellValue(ts);
                    } else if (val instanceof Boolean b) {
                        cell.setCellValue(b);
                    } else {
                        cell.setCellValue(val.toString());
                    }
                }
                count++;
            }
            return count;
        }

        void autoSizeAllColumns() {
            Row hdr = sheet.getRow(0);
            if (hdr == null) return;
            int last = hdr.getLastCellNum();
            for (int c = 0; c < last; c++) {
                try { sheet.autoSizeColumn(c); } catch (Exception ignored) {}
            }
        }
    }

    private record PreparedQuery(String sql, int paramCount) {}

    private static String nowStamp() {
        return LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss"));
    }
}

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.streaming.SXSSFSheet;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * MultiQueryExcelExporter — Per-Key Streaming Edition (Windows Auth + Multi-Env)
 * -----------------------------------------------------------------------------
 * - Reads 6 queries from Excel (Sheet 0, cells A1..A6)
 * - Executes Query #1 to get keys (single-column)
 * - Executes Queries #2..#6 once per key if tokens exist, otherwise runs once as-is
 * - Writes results into Excel with named sheets:
 *      Query 1 - Duplicate
 *      Query 2 - Invalid
 *      Query 3 - Datemismatch
 *      Query 4 - Invalid amount
 *      Query 5 - Exec
 * - Connects to SQL Server using Windows Integrated Auth, with DB chosen based
 *   on environment (SIT, UAT, PROD, etc.) provided as a program argument.
 */
public class MultiQueryExcelExporter {

    private static final String DEFAULT_INPUT_XLSX  = "./queries.xlsx";
    private static final String DEFAULT_OUTPUT_XLSX = "./results-" + nowStamp() + ".xlsx";

    // Map environments to connection URLs (Windows Integrated Auth)
    private static final Map<String,String> ENV_URLS = Map.of(
            "SIT",  "jdbc:sqlserver://sit-host:1433;databaseName=YourDB_SIT;encrypt=true;trustServerCertificate=true;integratedSecurity=true",
            "UAT",  "jdbc:sqlserver://uat-host:1433;databaseName=YourDB_UAT;encrypt=true;trustServerCertificate=true;integratedSecurity=true",
            "PROD", "jdbc:sqlserver://prod-host:1433;databaseName=YourDB_PROD;encrypt=true;trustServerCertificate=true;integratedSecurity=true"
    );

    private static final int FETCH_SIZE = 10_000;

    // Tokens that indicate per-key queries
    private static final Pattern FSID_TOKEN        = Pattern.compile(":FSID", Pattern.CASE_INSENSITIVE);
    private static final Pattern KEY_TOKEN         = Pattern.compile("\{\{\s*KEY\s*\}}", Pattern.CASE_INSENSITIVE);
    private static final Pattern QUOTED_FSID_TOKEN = Pattern.compile("'\s*:FSID\s*'", Pattern.CASE_INSENSITIVE);
    private static final Pattern QUOTED_KEY_TOKEN  = Pattern.compile("'\s*\{\{\s*KEY\s*\}}\s*'", Pattern.CASE_INSENSITIVE);

    // Desired sheet names for Q2..Q6
    private static final String[] SHEET_NAMES = {
            "Query 1 - Duplicate",
            "Query 2 - Invalid",
            "Query 3 - Datemismatch",
            "Query 4 - Invalid amount",
            "Query 5 - Exec"
    };

    public static void main(String[] args) throws Exception {
        if (args.length < 1) {
            throw new IllegalArgumentException("Usage: java MultiQueryExcelExporter <ENV> [input.xlsx] [output.xlsx]");
        }
        final String env = args[0].toUpperCase(Locale.ROOT);
        final String jdbcUrl = ENV_URLS.get(env);
        if (jdbcUrl == null) {
            throw new IllegalArgumentException("Unknown environment: " + env + ". Supported: " + ENV_URLS.keySet());
        }

        final Path inputPath  = Paths.get(args.length > 1 ? args[1] : DEFAULT_INPUT_XLSX);
        final Path outputPath = Paths.get(args.length > 2 ? args[2] : DEFAULT_OUTPUT_XLSX);

        System.out.println("→ Environment: " + env);
        System.out.println("→ Input queries:  " + inputPath.toAbsolutePath());
        System.out.println("→ Output workbook: " + outputPath.toAbsolutePath());

        final List<String> queries = readSixQueries(inputPath);
        if (queries.size() < 6) {
            throw new IllegalStateException("Expected 6 queries in A1..A6 of the first sheet; got " + queries.size());
        }

        try (Connection conn = newConnection(jdbcUrl);
             SXSSFWorkbook wb = new SXSSFWorkbook(1000)) {

            wb.setCompressTempFiles(true);

            // 1) Run key query
            final String keySql = queries.get(0);
            final List<String> keys = fetchKeys(conn, keySql);
            System.out.println("✔ Key count: " + keys.size());

            // 2) Prepare writers for Q2..Q6 with custom sheet names
            final Map<Integer, SheetWriter> writers = new LinkedHashMap<>();
            for (int i = 1; i <= 5; i++) {
                final String sheetName = SHEET_NAMES[i-1];
                writers.put(i, new SheetWriter(wb.createSheet(sheetName)));
            }

            // 3) For each downstream query, execute either per-key or once if no tokens
            for (int qi = 1; qi <= 5; qi++) {
                final String raw = queries.get(qi);
                final PreparedQuery pq = preparePerKeyStatement(raw);
                final SheetWriter writer = writers.get(qi);

                final boolean perKey = pq.paramCount > 0;
                writer.useKeyColumn(perKey);

                System.out.println("→ Executing query " + (qi + 1) + (perKey ? " per-key" : " (no key tokens)") +
                        " into sheet '" + writer.sheet.getSheetName() + "' …");

                if (perKey) {
                    try (PreparedStatement ps = conn.prepareStatement(pq.sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
                        ps.setFetchSize(FETCH_SIZE);

                        // sanity: if driver can report parameter count, ensure it's >0
                        try {
                            int jdbcParams = ps.getParameterMetaData().getParameterCount();
                            if (jdbcParams == 0) {
                                throw new IllegalArgumentException("No JDBC parameters after token replacement. SQL=
" + pq.sql);
                            }
                        } catch (SQLException ignored) { /* some drivers don't support this */ }

                        boolean headerWritten = false;
                        long totalRows = 0;
                        for (String key : keys) {
                            final String bind = key == null ? null : key.trim();
                            for (int p = 1; p <= pq.paramCount; p++) ps.setString(p, bind);
                            try (ResultSet rs = ps.executeQuery()) {
                                if (!headerWritten) { writer.writeHeader(rs.getMetaData()); headerWritten = true; }
                                totalRows += writer.appendRows(rs, bind);
                            }
                        }
                        writer.autoSizeAllColumns();
                        System.out.println("   ✔ Rows written (" + writer.sheet.getSheetName() + "): " + totalRows);
                    }
                } else {
                    try (Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
                        st.setFetchSize(FETCH_SIZE);
                        boolean headerWritten = false;
                        long totalRows = 0;
                        try (ResultSet rs = st.executeQuery(pq.sql)) {
                            if (!headerWritten) { writer.writeHeader(rs.getMetaData()); headerWritten = true; }
                            totalRows += writer.appendRows(rs, null);
                        }
                        writer.autoSizeAllColumns();
                        System.out.println("   ✔ Rows written (" + writer.sheet.getSheetName() + "): " + totalRows);
                    }
                }
            }

            // 4) Save workbook
            try (FileOutputStream fos = new FileOutputStream(outputPath.toFile())) {
                wb.write(fos);
            }
            System.out.println("✔ Done. Workbook saved: " + outputPath.toAbsolutePath());
        }
    }

    private static Connection newConnection(String jdbcUrl) throws SQLException {
        return DriverManager.getConnection(jdbcUrl);
    }

    private static List<String> readSixQueries(Path xlsx) throws IOException {
        List<String> list = new ArrayList<>(6);
        try (FileInputStream fis = new FileInputStream(xlsx.toFile());
             Workbook wb = WorkbookFactory.create(fis)) {
            Sheet s = wb.getSheetAt(0);
            for (int r = 0; r < 6; r++) {
                Row row = s.getRow(r);
                if (row == null) continue;
                Cell c = row.getCell(0);
                if (c == null) continue;
                c.setCellType(CellType.STRING);
                String sql = c.getStringCellValue();
                if (sql != null && !sql.isBlank()) list.add(sql.trim());
            }
        }
        return list;
    }

    private static List<String> fetchKeys(Connection conn, String keySql) throws SQLException {
        List<String> keys = new ArrayList<>(2048);
        try (Statement st = conn.createStatement();
             ResultSet rs = st.executeQuery(keySql)) {
            ResultSetMetaData md = rs.getMetaData();
            if (md.getColumnCount() != 1) {
                throw new IllegalStateException("Key query must return exactly 1 column; got " + md.getColumnCount());
            }
            while (rs.next()) {
                Object val = rs.getObject(1);
                if (val != null) keys.add(val.toString());
            }
        }
        return keys;
    }

    /**
     * Replace placeholder tokens with JDBC '?' and count how many we created.
     * If no tokens are present, returns the original SQL with paramCount=0.
     */
    private static PreparedQuery preparePerKeyStatement(String raw) {
        String sql = raw;
        int count = 0;
        StringBuffer sb;

        // Replace quoted tokens first (e.g., ':FSID' or '{{KEY}}')
        Matcher q1 = QUOTED_FSID_TOKEN.matcher(sql);
        sb = new StringBuffer();
        while (q1.find()) { q1.appendReplacement(sb, "?"); count++; }
        q1.appendTail(sb); sql = sb.toString();

        Matcher q2 = QUOTED_KEY_TOKEN.matcher(sql);
        sb = new StringBuffer();
        while (q2.find()) { q2.appendReplacement(sb, "?"); count++; }
        q2.appendTail(sb); sql = sb.toString();

        // Replace unquoted tokens
        Matcher m1 = FSID_TOKEN.matcher(sql);
        sb = new StringBuffer();
        while (m1.find()) { m1.appendReplacement(sb, "?"); count++; }
        m1.appendTail(sb); sql = sb.toString();

        Matcher m2 = KEY_TOKEN.matcher(sql);
        sb = new StringBuffer();
        while (m2.find()) { m2.appendReplacement(sb, "?"); count++; }
        m2.appendTail(sb); sql = sb.toString();

        return new PreparedQuery(sql, count);
    }

    private static final class SheetWriter {
        final SXSSFSheet sheet;
        int nextRow = 0;
        private boolean keyColumn = true; // include a leading Key column by default

        SheetWriter(SXSSFSheet sheet) {
            this.sheet = sheet;
            this.sheet.trackAllColumnsForAutoSizing();
        }

        void useKeyColumn(boolean use) { this.keyColumn = use; }

        void writeHeader(ResultSetMetaData md) throws SQLException {
            Row hdr = sheet.createRow(nextRow++);
            int col = 0;
            if (keyColumn) {
                Cell keyCell = hdr.createCell(col++, CellType.STRING);
                keyCell.setCellValue("Key");
            }
            for (int c = 1; c <= md.getColumnCount(); c++) {
                Cell cell = hdr.createCell(col++, CellType.STRING);
                cell.setCellValue(md.getColumnLabel(c));
            }
        }

        long appendRows(ResultSet rs, String key) throws SQLException {
            long count = 0;
            final int cols = rs.getMetaData().getColumnCount();
            while (rs.next()) {
                Row row = sheet.createRow(nextRow++);
                int col = 0;
                if (keyColumn) {
                    row.createCell(col++, CellType.STRING).setCellValue(key == null ? "" : key);
                }
                for (int c = 1; c <= cols; c++) {
                    Object val = rs.getObject(c);
                    Cell cell = row.createCell(col++);
                    if (val == null) {
                        cell.setBlank();
                    } else if (val instanceof Number num) {
                        cell.setCellValue(num.doubleValue());
                    } else if (val instanceof java.sql.Date d) {
                        cell.setCellValue(d);
                    } else if (val instanceof java.sql.Timestamp ts) {
                        cell.setCellValue(ts);
                    } else if (val instanceof Boolean b) {
                        cell.setCellValue(b);
                    } else {
                        cell.setCellValue(val.toString());
                    }
                }
                count++;
            }
            return count;
        }

        void autoSizeAllColumns() {
            Row hdr = sheet.getRow(0);
            if (hdr == null) return;
            int last = hdr.getLastCellNum();
            for (int c = 0; c < last; c++) {
                try { sheet.autoSizeColumn(c); } catch (Exception ignored) {}
            }
        }
    }

    private record PreparedQuery(String sql, int paramCount) {}

    private static String nowStamp() {
        return LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss"));
    }
}

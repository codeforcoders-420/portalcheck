import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.streaming.SXSSFSheet;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * MultiQueryExcelExporter — Per-Key Streaming Edition (Windows Auth)
 * -----------------------------------------------------------------
 * Java 17 utility that:
 *   1) Reads 6 SQL queries from an Excel file (Sheet 0, cells A1..A6)
 *   2) Executes Query #1 to get a single-column list of keys (e.g., ~1600 FSIDs)
 *   3) For each of Queries #2..#6, executes the query ONCE PER KEY, binding the
 *      key value anywhere the token appears: :FSID or {{KEY}} (quoted or unquoted)
 *   4) Streams all returned rows into an output workbook with sheets Q2..Q6.
 *      An extra first column "Key" shows which key produced that row.
 *
 * Why this design:
 *   - Avoids giant IN() lists and temp tables
 *   - Handles self-joins (you can use the token twice in the same query)
 *   - Memory-safe for large data (SXSSF streaming)
 *
 * Tokens it understands in Queries #2..#6:
 *   - :FSID
 *   - '{{KEY}}' (with or without quotes; quotes are stripped automatically)
 *   - You can use the token multiple times; the same bound value will be used.
 *
 * JDBC: Windows Integrated Authentication (SSPI) for Microsoft SQL Server.
 * Make sure the appropriate mssql-jdbc_auth-<arch>.dll is on PATH or in -Djava.library.path.
 */
public class MultiQueryExcelExporter {

    // ==== Configuration =====================================================
    private static final String DEFAULT_INPUT_XLSX  = "./queries.xlsx"; // A1..A6 on Sheet 0
    private static final String DEFAULT_OUTPUT_XLSX = "./results-" + nowStamp() + ".xlsx";

    // Windows Integrated Auth (change host/db or override with -Djdbc.url=...)
    private static final String JDBC_URL = System.getProperty(
            "jdbc.url",
            "jdbc:sqlserver://localhost:1433;databaseName=YourDB;encrypt=true;trustServerCertificate=true;integratedSecurity=true"
    );

    private static final int FETCH_SIZE = 10_000; // driver hint

    // Token patterns
    private static final Pattern FSID_TOKEN           = Pattern.compile(":FSID", Pattern.CASE_INSENSITIVE);
    private static final Pattern KEY_TOKEN            = Pattern.compile("\{\{\s*KEY\s*\}}", Pattern.CASE_INSENSITIVE);
    private static final Pattern QUOTED_FSID_TOKEN    = Pattern.compile("'\s*:FSID\s*'", Pattern.CASE_INSENSITIVE);
    private static final Pattern QUOTED_KEY_TOKEN     = Pattern.compile("'\s*\{\{\s*KEY\s*\}}\s*'", Pattern.CASE_INSENSITIVE);

    public static void main(String[] args) throws Exception {
        final Path inputPath  = Paths.get(args.length > 0 ? args[0] : DEFAULT_INPUT_XLSX);
        final Path outputPath = Paths.get(args.length > 1 ? args[1] : DEFAULT_OUTPUT_XLSX);

        System.out.println("→ Input queries:  " + inputPath.toAbsolutePath());
        System.out.println("→ Output workbook: " + outputPath.toAbsolutePath());

        final List<String> queries = readSixQueries(inputPath);
        if (queries.size() < 6) {
            throw new IllegalStateException("Expected 6 queries in A1..A6 of the first sheet; got " + queries.size());
        }

        try (Connection conn = newConnection();
             SXSSFWorkbook wb = new SXSSFWorkbook(1000)) { // keep 1000 rows in memory per sheet

            wb.setCompressTempFiles(true);

            // 1) Run key query
            final String keySql = queries.get(0);
            final List<String> keys = fetchKeys(conn, keySql);
            System.out.println("✔ Key count: " + keys.size());

            // 2) Prepare writers for Q2..Q6
            final Map<Integer, SheetWriter> writers = new LinkedHashMap<>();
            for (int i = 1; i <= 5; i++) {
                final String sheetName = "Q" + (i + 1);
                writers.put(i, new SheetWriter(wb.createSheet(sheetName)));
            }

            // 3) For each downstream query, execute per key and stream rows
            for (int qi = 1; qi <= 5; qi++) {
                final String raw = queries.get(qi);
                final PreparedQuery pq = preparePerKeyStatement(raw);
                final SheetWriter writer = writers.get(qi);

                System.out.println("→ Executing query " + (qi + 1) + " per-key into sheet '" + writer.sheet.getSheetName() + "' …");

                try (PreparedStatement ps = conn.prepareStatement(pq.sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
                    ps.setFetchSize(FETCH_SIZE);

                    // Sanity check: ensure JDBC sees parameters post-replacement
                    int jdbcParams = 0;
                    try {
                        jdbcParams = ps.getParameterMetaData().getParameterCount();
                    } catch (SQLException ignore) { /* some drivers might not support */ }
                    if (jdbcParams == 0) {
                        throw new IllegalArgumentException(
                                "This query has no JDBC parameters after token replacement.
" +
                                "Likely cause: token inside a comment or not parsed as SQL.
SQL after replacement:
" + pq.sql);
                    }

                    boolean headerWritten = false;
                    long totalRows = 0;

                    for (String key : keys) {
                        final String bind = key == null ? null : key.trim();
                        for (int p = 1; p <= pq.paramCount; p++) {
                            ps.setString(p, bind);
                        }
                        try (ResultSet rs = ps.executeQuery()) {
                            if (!headerWritten) {
                                writer.writeHeader(rs.getMetaData());
                                headerWritten = true;
                            }
                            totalRows += writer.appendRows(rs, bind);
                        }
                    }

                    writer.autoSizeAllColumns();
                    System.out.println("   ✔ Rows written (Q" + (qi + 1) + "): " + totalRows);
                }
            }

            // 4) Save workbook
            try (FileOutputStream fos = new FileOutputStream(outputPath.toFile())) {
                wb.write(fos);
            }
            System.out.println("✔ Done. Workbook saved: " + outputPath.toAbsolutePath());
        }
    }

    // === JDBC helpers =======================================================
    private static Connection newConnection() throws SQLException {
        // With integratedSecurity=true, the Microsoft JDBC driver uses your current Windows credentials.
        return DriverManager.getConnection(JDBC_URL);
    }

    // === Excel/Query helpers ===============================================
    private static List<String> readSixQueries(Path xlsx) throws IOException {
        List<String> list = new ArrayList<>(6);
        try (FileInputStream fis = new FileInputStream(xlsx.toFile());
             Workbook wb = WorkbookFactory.create(fis)) {
            Sheet s = wb.getSheetAt(0);
            for (int r = 0; r < 6; r++) {
                Row row = s.getRow(r);
                if (row == null) continue;
                Cell c = row.getCell(0);
                if (c == null) continue;
                c.setCellType(CellType.STRING);
                String sql = c.getStringCellValue();
                if (sql != null && !sql.isBlank()) list.add(sql.trim());
            }
        }
        return list;
    }

    private static List<String> fetchKeys(Connection conn, String keySql) throws SQLException {
        List<String> keys = new ArrayList<>(2048);
        try (Statement st = conn.createStatement();
             ResultSet rs = st.executeQuery(keySql)) {
            ResultSetMetaData md = rs.getMetaData();
            if (md.getColumnCount() != 1) {
                throw new IllegalStateException("Key query must return exactly 1 column; got " + md.getColumnCount());
            }
            while (rs.next()) {
                Object val = rs.getObject(1);
                if (val != null) keys.add(val.toString());
            }
        }
        return keys;
    }

    // Replace tokens with '?' and count how many parameters we created
    private static PreparedQuery preparePerKeyStatement(String raw) {
        String sql = raw;
        int count = 0;
        StringBuffer sb;

        // 1) Replace quoted tokens first (e.g., ':FSID' or '{{KEY}}') → '?'
        Matcher q1 = QUOTED_FSID_TOKEN.matcher(sql);
        sb = new StringBuffer();
        while (q1.find()) { q1.appendReplacement(sb, "?"); count++; }
        q1.appendTail(sb); sql = sb.toString();

        Matcher q2 = QUOTED_KEY_TOKEN.matcher(sql);
        sb = new StringBuffer();
        while (q2.find()) { q2.appendReplacement(sb, "?"); count++; }
        q2.appendTail(sb); sql = sb.toString();

        // 2) Replace unquoted tokens → '?'
        Matcher m1 = FSID_TOKEN.matcher(sql);
        sb = new StringBuffer();
        while (m1.find()) { m1.appendReplacement(sb, "?"); count++; }
        m1.appendTail(sb); sql = sb.toString();

        Matcher m2 = KEY_TOKEN.matcher(sql);
        sb = new StringBuffer();
        while (m2.find()) { m2.appendReplacement(sb, "?"); count++; }
        m2.appendTail(sb); sql = sb.toString();

        if (count == 0) {
            throw new IllegalArgumentException("Downstream query is missing :FSID or {{KEY}} token(s):
" + raw);
        }
        return new PreparedQuery(sql, count);
    }

    // === Sheet writer =======================================================
    private static final class SheetWriter {
        final SXSSFSheet sheet;
        int nextRow = 0;

        SheetWriter(SXSSFSheet sheet) {
            this.sheet = sheet;
            this.sheet.trackAllColumnsForAutoSizing();
        }

        void writeHeader(ResultSetMetaData md) throws SQLException {
            Row hdr = sheet.createRow(nextRow++);
            // First column is the bound key
            Cell keyCell = hdr.createCell(0, CellType.STRING);
            keyCell.setCellValue("Key");
            for (int c = 1; c <= md.getColumnCount(); c++) {
                Cell cell = hdr.createCell(c, CellType.STRING);
                cell.setCellValue(md.getColumnLabel(c));
            }
        }

        long appendRows(ResultSet rs, String key) throws SQLException {
            long count = 0;
            final int cols = rs.getMetaData().getColumnCount();
            while (rs.next()) {
                Row row = sheet.createRow(nextRow++);
                row.createCell(0, CellType.STRING).setCellValue(key == null ? "" : key);
                for (int c = 1; c <= cols; c++) {
                    Object val = rs.getObject(c);
                    Cell cell = row.createCell(c);
                    if (val == null) {
                        cell.setBlank();
                    } else if (val instanceof Number num) {
                        cell.setCellValue(num.doubleValue());
                    } else if (val instanceof java.sql.Date d) {
                        cell.setCellValue(d);
                    } else if (val instanceof java.sql.Timestamp ts) {
                        cell.setCellValue(ts);
                    } else if (val instanceof Boolean b) {
                        cell.setCellValue(b);
                    } else {
                        cell.setCellValue(val.toString());
                    }
                }
                count++;
            }
            return count;
        }

        void autoSizeAllColumns() {
            Row hdr = sheet.getRow(0);
            if (hdr == null) return;
            int last = hdr.getLastCellNum();
            for (int c = 0; c < last; c++) {
                try { sheet.autoSizeColumn(c); } catch (Exception ignored) {}
            }
        }
    }

    private record PreparedQuery(String sql, int paramCount) {}

    private static String nowStamp() {
        return LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss"));
    }
}

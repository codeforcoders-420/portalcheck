<script>
  // …your existing const prOpenBtn, prCloseBtn, prRun, prEnv, prModal, etc. remain as-is…

  // --- ADD/REPLACE THIS HANDLER ---
  prRun.addEventListener('click', async (e) => {
    e.preventDefault();

    // Prevent double clicks
    if (prRun.disabled) return;

    // Swap label to "Report running" and lock the button
    const previousText = prRun.textContent;
    prRun.textContent = 'Report running';
    prRun.disabled = true;
    prRun.setAttribute('aria-busy', 'true');

    try {
      // ⬇️ Call your existing execute function OR backend endpoint
      // If you already have a function (e.g., prExecute), call that:
      // await prExecute(prEnv.value);

      // If you post to your Spring Boot endpoint, use:
      const res = await fetch('/runValidation', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ env: prEnv?.value })
      });
      if (!res.ok) throw new Error('Validation failed');

      // Optional: handle response if needed
      // const data = await res.json();
      // showToast('Validation complete'); // if you have a toast
    } catch (err) {
      console.error(err);
      // Optional: show an error message in your UI
      // showError('Validation failed. Please try again.');
    } finally {
      // Always restore the button text/state
      prRun.textContent = previousText || 'Run Validation';
      prRun.disabled = false;
      prRun.removeAttribute('aria-busy');
    }
  });

  // (Keep the rest of your script the same)
</script>


**************************

#prRun[disabled] {
  opacity: 0.6;
  cursor: not-allowed;
}

***************************************

document.addEventListener('DOMContentLoaded', () => {
  const prRun = document.getElementById('prRun');
  const prEnv = document.getElementById('prEnv');

  if (!prRun) {
    console.warn('Run button #prRun not found');
    return;
  }

  prRun.addEventListener('click', (e) => {
    // 1) kill form submit / bubbling that might reload the page
    e.preventDefault();
    e.stopPropagation();

    if (prRun.disabled) return; // guard double clicks

    const previousText = prRun.textContent;
    prRun.textContent = 'Report running';
    prRun.disabled = true;
    prRun.setAttribute('aria-busy', 'true');

    // 2) If your work is synchronous (CPU-heavy) the UI won't repaint.
    //    Use requestAnimationFrame to force a paint before starting work.
    requestAnimationFrame(async () => {
      try {
        // --- start your actual run here ---
        // If you call backend:
        /*
        const res = await fetch('/runValidation', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ env: prEnv?.value })
        });
        if (!res.ok) throw new Error('Validation failed');
        */

        // If you currently call a synchronous function like processExport(),
        // wrap it so the label shows first:
        // await new Promise((resolve) => setTimeout(() => { processExport(); resolve(); }, 0));

        // demo delay:
        await new Promise(r => setTimeout(r, 2000));
        // --- end work ---
      } catch (err) {
        console.error(err);
        // show toast/error UI if needed
      } finally {
        // 3) Always restore UI
        prRun.textContent = previousText || 'Run Validation';
        prRun.disabled = false;
        prRun.removeAttribute('aria-busy');
      }
    });
  });

  // If the button lives inside a <form>, also block default submit there:
  prRun.closest('form')?.addEventListener('submit', (ev) => ev.preventDefault());
});


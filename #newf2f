import com.univocity.parsers.common.record.Record;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

import java.io.Reader;
import java.io.Writer;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;

/**
 * Source vs Target CSV comparator
 * --------------------------------
 * - Reads "input/Source.csv" and "input/Target.csv"
 * - Keeps ALL rows per 5-key (Procedure Code + Modifiers)
 * - Removes exact and partial matches
 * - Writes diff-output/differences_source_vs_target.csv
 * - "Differences" lists mismatched columns and src/tgt values
 */
public class SourceTargetDiff {

    /* ========================== CONFIG ========================== */

    private static final Path INPUT_DIR  = Path.of("input");
    private static final Path OUTPUT_DIR = Path.of("diff-output");

    private static final Path SOURCE_CSV = INPUT_DIR.resolve("Source.csv");
    private static final Path TARGET_CSV = INPUT_DIR.resolve("Target.csv");

    private static final List<String> MOD_KEY_COLS = List.of(
            "Procedure Code", "Modifier", "Modifier2", "Modifier3", "Modifier4"
    );
    private static final List<String> EXACT_COMPARE = List.of(
            "Effective", "Termination", "Reimb Method", "Allowed", "Percent"
    );
    private static final List<String> PARTIAL_COMPARE = List.of(
            "Termination", "Reimb Method", "Allowed", "Percent"
    );
    private static final List<String> OUTPUT_COLS = List.of(
            "Procedure Code", "Modifier", "Modifier2", "Modifier3", "Modifier4",
            "Effective", "Termination", "Reimb Method", "Allowed", "Percent", "Differences"
    );

    /* ========================== TYPES ========================== */

    private record Key(List<String> values) {
        static Key from(Map<String,String> row, List<String> cols) {
            return new Key(cols.stream().map(c -> normalizeCell(row.get(c))).toList());
        }
    }

    private record CsvData(List<String> headers,
                           Map<Key, List<Map<String,String>>> rowsByKey) {}

    /* ========================== MAIN ========================== */

    public static void main(String[] args) throws Exception {
        if (!Files.exists(INPUT_DIR))
            throw new IllegalStateException("Missing input folder: " + INPUT_DIR.toAbsolutePath());
        Files.createDirectories(OUTPUT_DIR);

        if (!Files.exists(SOURCE_CSV) || !Files.exists(TARGET_CSV)) {
            System.err.println("❌ Missing Source.csv or Target.csv in " + INPUT_DIR.toAbsolutePath());
            return;
        }

        CsvData source = readCsvAsMap(SOURCE_CSV);
        CsvData target = readCsvAsMap(TARGET_CSV);

        requireColumns(source, "Source", MOD_KEY_COLS, EXACT_COMPARE);
        requireColumns(target, "Target", MOD_KEY_COLS, EXACT_COMPARE);

        List<Map<String,String>> diffs = diffSourceVsTarget(source, target);

        Path out = OUTPUT_DIR.resolve("differences_source_vs_target.csv");
        writeSlimCsv(out, diffs);

        System.out.printf("✅ Compared %d source rows → %d differences written to %s%n",
                source.rowsByKey().values().stream().mapToInt(List::size).sum(),
                diffs.size(), out.toAbsolutePath());
    }

    /* ========================== CORE LOGIC ========================== */

    private static List<Map<String,String>> diffSourceVsTarget(CsvData source, CsvData target) {
        Map<Key, List<Map<String,String>>> tgtByKey = target.rowsByKey();
        List<Map<String,String>> out = new ArrayList<>();

        for (var e : source.rowsByKey().entrySet()) {
            for (var sRow : e.getValue()) {
                Key k = Key.from(sRow, MOD_KEY_COLS);
                List<Map<String,String>> candidates = tgtByKey.get(k);

                if (candidates == null || candidates.isEmpty()) {
                    out.add(makeOutRow(sRow, "Key Missing"));
                    continue;
                }

                boolean exact = candidates.stream().anyMatch(t -> rowMatchesOn(sRow, t, EXACT_COMPARE));
                if (exact) continue;

                boolean partial = candidates.stream().anyMatch(t -> rowMatchesOn(sRow, t, PARTIAL_COMPARE));
                if (partial) continue;

                Map<String,String> best = chooseBestMatch(sRow, candidates, EXACT_COMPARE);
                String details = buildDifferencesDetail(sRow, best, EXACT_COMPARE);
                out.add(makeOutRow(sRow, details));
            }
        }
        return out;
    }

    /* ========================== HELPERS ========================== */

    private static CsvData readCsvAsMap(Path path) throws IOException {
        var s = new CsvParserSettings();
        s.setHeaderExtractionEnabled(true);
        s.setLineSeparatorDetectionEnabled(true);
        s.setNullValue("");
        s.setEmptyValue("");
        s.setMaxColumns(4096);
        var parser = new CsvParser(s);

        List<String> headers;
        Map<Key,List<Map<String,String>>> rowsByKey = new LinkedHashMap<>();

        try (Reader r = Files.newBufferedReader(path)) {
            parser.beginParsing(r);
            headers = List.of(parser.getRecordMetadata().headers());
            Record rec;
            while ((rec = parser.parseNextRecord()) != null) {
                Map<String,String> row = new LinkedHashMap<>();
                for (String h : headers) row.put(h, rec.getString(h));
                Key k = Key.from(row, MOD_KEY_COLS);
                rowsByKey.computeIfAbsent(k, __ -> new ArrayList<>()).add(row);
            }
        }
        return new CsvData(headers, rowsByKey);
    }

    private static void requireColumns(CsvData data, String label,
                                       List<String> keyCols, List<String> cmpCols) {
        List<String> missing = new ArrayList<>();
        for (String h : keyCols) if (!data.headers().contains(h)) missing.add(h);
        for (String h : cmpCols) if (!data.headers().contains(h)) missing.add(h);
        if (!missing.isEmpty()) {
            throw new IllegalArgumentException(label + " CSV missing columns: " + missing);
        }
    }

    private static boolean rowMatchesOn(Map<String,String> a, Map<String,String> b, List<String> cols) {
        for (String c : cols)
            if (!Objects.equals(normalizeCell(a.get(c)), normalizeCell(b.get(c)))) return false;
        return true;
    }

    private static Map<String,String> chooseBestMatch(Map<String,String> src,
                                                      List<Map<String,String>> candidates,
                                                      List<String> cols) {
        Map<String,String> best = candidates.get(0);
        int bestScore = -1;
        for (var t : candidates) {
            int score = 0;
            for (String c : cols)
                if (Objects.equals(normalizeCell(src.get(c)), normalizeCell(t.get(c)))) score++;
            if (score > bestScore) { bestScore = score; best = t; }
        }
        return best;
    }

    private static Map<String,String> makeOutRow(Map<String,String> src, String differences) {
        Map<String,String> m = new LinkedHashMap<>();
        for (String c : OUTPUT_COLS) {
            if (!"Differences".equals(c)) m.put(c, raw(src, c));
        }
        m.put("Differences", differences);
        return m;
    }

    private static String raw(Map<String,String> row, String col) {
        String v = row == null ? null : row.get(col);
        return v == null ? "" : v.trim();
    }

    private static String buildDifferencesDetail(Map<String,String> src,
                                                 Map<String,String> tgt,
                                                 List<String> compareCols) {
        List<String> parts = new ArrayList<>();
        for (String c : compareCols) {
            String sNorm = normalizeCell(src.get(c));
            String tNorm = normalizeCell(tgt.get(c));
            if (!Objects.equals(sNorm, tNorm)) {
                parts.add(c + "(src=" + raw(src, c) + ", tgt=" + raw(tgt, c) + ")");
            }
        }
        return parts.isEmpty() ? "" : String.join(" | ", parts);
    }

    private static String normalizeCell(String s) {
        if (s == null) return null;
        String t = s.trim();
        if (t.isEmpty()) return null;

        LocalDate d = tryParseDate(t);
        if (d != null) return d.toString();

        String cleaned = t.replace(",", "");
        if (cleaned.startsWith("$")) cleaned = cleaned.substring(1);
        try {
            BigDecimal bd = new BigDecimal(cleaned);
            bd = bd.stripTrailingZeros();
            return bd.toPlainString();
        } catch (NumberFormatException ignore) {}

        return cleaned.replaceAll("\\s+", " ");
    }

    private static final List<DateTimeFormatter> DATE_FORMATS = List.of(
            DateTimeFormatter.ISO_LOCAL_DATE,
            DateTimeFormatter.ofPattern("M/d/uuuu"),
            DateTimeFormatter.ofPattern("MM/dd/uuuu"),
            DateTimeFormatter.ofPattern("M/d/uu"),
            DateTimeFormatter.ofPattern("MM/dd/uu")
    );

    private static LocalDate tryParseDate(String s) {
        for (var fmt : DATE_FORMATS) {
            try { return LocalDate.parse(s, fmt); }
            catch (DateTimeParseException ignore) {}
        }
        return null;
    }

    private static void writeSlimCsv(Path out, List<Map<String,String>> rows) throws IOException {
        var settings = new CsvWriterSettings();
        settings.setHeaderWritingEnabled(true);
        try (Writer w = Files.newBufferedWriter(out)) {
            var writer = new CsvWriter(w, settings);
            writer.writeHeaders(OUTPUT_COLS.toArray(new String[0]));
            for (var r : rows) {
                List<String> line = new ArrayList<>(OUTPUT_COLS.size());
                for (String c : OUTPUT_COLS) line.add(r.getOrDefault(c, ""));
                writer.writeRow(line);
            }
            writer.close();
        }
    }
}

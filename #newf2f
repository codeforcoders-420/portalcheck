import com.univocity.parsers.common.record.Record;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

import java.io.Reader;
import java.io.Writer;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;

/**
 * Bi-directional CSV comparator
 * -----------------------------
 * Reads:   input/Source.csv, input/Target.csv
 * Writes:  diff-output/differences_bidirectional.csv
 *
 * For each direction (A→B):
 *  - Keep ALL rows per 5-key (Procedure Code, Modifier, Modifier2, Modifier3, Modifier4)
 *  - Ignore exact matches (key + Effective/Termination/Reimb Method/Allowed/Percent)
 *  - Ignore partial matches (key + Termination/Reimb Method/Allowed/Percent)
 *  - Otherwise, report row with Differences (which fields differ + src/tgt values)
 *  - If key missing on right, Differences="Key Missing"
 *
 * Output columns (12): Direction + your 11 requested columns
 */
public class BidirectionalDiff {

    /* ========================== CONFIG ========================== */

    private static final Path INPUT_DIR  = Path.of("input");
    private static final Path OUTPUT_DIR = Path.of("diff-output");

    private static final Path SOURCE_CSV = INPUT_DIR.resolve("Source.csv");
    private static final Path TARGET_CSV = INPUT_DIR.resolve("Target.csv");

    // 5-key combo used to group rows (PRESERVE ALL rows per key)
    private static final List<String> MOD_KEY_COLS = List.of(
            "Procedure Code", "Modifier", "Modifier2", "Modifier3", "Modifier4"
    );

    // Compare sets
    private static final List<String> EXACT_COMPARE = List.of(
            "Effective", "Termination", "Reimb Method", "Allowed", "Percent"
    );
    private static final List<String> PARTIAL_COMPARE = List.of(
            "Termination", "Reimb Method", "Allowed", "Percent"
    );

    // Output columns (Direction + your 11)
    private static final List<String> OUTPUT_COLS = List.of(
            "Direction",
            "Procedure Code", "Modifier", "Modifier2", "Modifier3", "Modifier4",
            "Effective", "Termination", "Reimb Method", "Allowed", "Percent", "Differences"
    );

    /* ========================== TYPES ========================== */

    // Composite key of normalized values (for reliable grouping)
    private record Key(List<String> values) {
        static Key from(Map<String, String> row, List<String> cols) {
            return new Key(cols.stream().map(c -> normalizeCell(row.get(c))).toList());
        }
    }

    // CSV data preserving ALL rows per key
    private record CsvData(List<String> headers,
                           Map<Key, List<Map<String, String>>> rowsByKey) {}

    /* ========================== MAIN ========================== */

    public static void main(String[] args) throws Exception {
        if (!Files.exists(INPUT_DIR))
            throw new IllegalStateException("Missing input folder: " + INPUT_DIR.toAbsolutePath());
        Files.createDirectories(OUTPUT_DIR);

        if (!Files.exists(SOURCE_CSV) || !Files.exists(TARGET_CSV)) {
            System.err.println("❌ Missing Source.csv or Target.csv in " + INPUT_DIR.toAbsolutePath());
            return;
        }

        CsvData source = readCsvAsMap(SOURCE_CSV);
        CsvData target = readCsvAsMap(TARGET_CSV);

        requireColumns(source, "Source", MOD_KEY_COLS, EXACT_COMPARE);
        requireColumns(target, "Target", MOD_KEY_COLS, EXACT_COMPARE);

        // Pass 1: Source -> Target
        List<Map<String,String>> s2t = compareOneWay("Source→Target", source, target);
        // Pass 2: Target -> Source
        List<Map<String,String>> t2s = compareOneWay("Target→Source", target, source);

        // Combine
        List<Map<String,String>> all = new ArrayList<>(s2t.size() + t2s.size());
        all.addAll(s2t);
        all.addAll(t2s);

        Path out = OUTPUT_DIR.resolve("differences_bidirectional.csv");
        writeSlimCsv(out, all);

        int sourceRows = source.rowsByKey().values().stream().mapToInt(List::size).sum();
        int targetRows = target.rowsByKey().values().stream().mapToInt(List::size).sum();

        System.out.printf("✅ Compared Source(%d rows) ↔ Target(%d rows)%n", sourceRows, targetRows);
        System.out.printf("   Differences: %d written to %s%n", all.size(), out.toAbsolutePath());
    }

    /* ========================== CORE LOGIC ========================== */

    /**
     * One-way comparison (left → right) using the specified rules.
     * Direction label is written to the output "Direction" column.
     */
    private static List<Map<String,String>> compareOneWay(String direction,
                                                          CsvData left,
                                                          CsvData right) {
        Map<Key, List<Map<String,String>>> rightByKey = right.rowsByKey();
        List<Map<String,String>> out = new ArrayList<>();

        for (var e : left.rowsByKey().entrySet()) {
            for (var lRow : e.getValue()) {
                Key k = Key.from(lRow, MOD_KEY_COLS);
                List<Map<String,String>> candidates = rightByKey.get(k);

                if (candidates == null || candidates.isEmpty()) {
                    out.add(makeOutRow(direction, lRow, "Key Missing"));
                    continue;
                }

                boolean exact = candidates.stream().anyMatch(r -> rowMatchesOn(lRow, r, EXACT_COMPARE));
                if (exact) continue; // ignore exact matches

                boolean partial = candidates.stream().anyMatch(r -> rowMatchesOn(lRow, r, PARTIAL_COMPARE));
                if (partial) continue; // ignore partial matches

                // Choose best match to show tgt values in Differences
                Map<String,String> best = chooseBestMatch(lRow, candidates, EXACT_COMPARE);
                String details = buildDifferencesDetail(lRow, best, EXACT_COMPARE);
                out.add(makeOutRow(direction, lRow, details));
            }
        }
        return out;
    }

    /* ========================== HELPERS ========================== */

    private static CsvData readCsvAsMap(Path path) throws IOException {
        CsvParserSettings s = new CsvParserSettings();
        s.setHeaderExtractionEnabled(true);
        s.setLineSeparatorDetectionEnabled(true);
        s.setNullValue("");
        s.setEmptyValue("");
        s.setMaxColumns(4096);

        CsvParser parser = new CsvParser(s);

        List<String> headers;
        Map<Key, List<Map<String, String>>> rowsByKey = new LinkedHashMap<>();

        try (Reader r = Files.newBufferedReader(path)) {
            parser.beginParsing(r);
            headers = List.of(parser.getRecordMetadata().headers());

            Record rec;
            while ((rec = parser.parseNextRecord()) != null) {
                Map<String, String> row = new LinkedHashMap<>();
                for (String h : headers) row.put(h, rec.getString(h));
                Key k = Key.from(row, MOD_KEY_COLS);
                rowsByKey.computeIfAbsent(k, __ -> new ArrayList<>()).add(row);
            }
        }
        return new CsvData(headers, rowsByKey);
    }

    private static void requireColumns(CsvData data, String label,
                                       List<String> keyCols, List<String> cmpCols) {
        List<String> missing = new ArrayList<>();
        for (String h : keyCols) if (!data.headers().contains(h)) missing.add(h);
        for (String h : cmpCols) if (!data.headers().contains(h)) missing.add(h);
        if (!missing.isEmpty()) {
            throw new IllegalArgumentException(label + " CSV missing columns: " + missing);
        }
    }

    private static boolean rowMatchesOn(Map<String,String> a, Map<String,String> b, List<String> cols) {
        for (String c : cols)
            if (!Objects.equals(normalizeCell(a.get(c)), normalizeCell(b.get(c)))) return false;
        return true;
    }

    // Choose the candidate that matches the most fields among 'cols'
    private static Map<String,String> chooseBestMatch(Map<String,String> left,
                                                      List<Map<String,String>> candidates,
                                                      List<String> cols) {
        Map<String,String> best = candidates.get(0);
        int bestScore = -1;
        for (var r : candidates) {
            int score = 0;
            for (String c : cols)
                if (Objects.equals(normalizeCell(left.get(c)), normalizeCell(r.get(c)))) score++;
            if (score > bestScore) { bestScore = score; best = r; }
        }
        return best;
    }

    private static Map<String,String> makeOutRow(String direction, Map<String,String> row, String differences) {
        Map<String,String> m = new LinkedHashMap<>();
        m.put("Direction", direction);
        for (String c : OUTPUT_COLS) {
            if ("Direction".equals(c) || "Differences".equals(c)) continue;
            m.put(c, raw(row, c));
        }
        m.put("Differences", differences);
        return m;
    }

    private static String raw(Map<String,String> row, String col) {
        String v = row == null ? null : row.get(col);
        return v == null ? "" : v.trim();
    }

    // "Allowed(src=123.45, tgt=120.00) | Effective(src=2024-09-01, tgt=2024-10-01)"
    private static String buildDifferencesDetail(Map<String,String> left,
                                                 Map<String,String> right,
                                                 List<String> compareCols) {
        List<String> parts = new ArrayList<>();
        for (String c : compareCols) {
            String lNorm = normalizeCell(left.get(c));
            String rNorm = normalizeCell(right.get(c));
            if (!Objects.equals(lNorm, rNorm)) {
                parts.add(c + "(src=" + raw(left, c) + ", tgt=" + raw(right, c) + ")");
            }
        }
        return parts.isEmpty() ? "" : String.join(" | ", parts);
    }

    // Normalize values: numbers ($, , stripping) and dates (to yyyy-MM-dd); trim/collapse whitespace
    private static String normalizeCell(String s) {
        if (s == null) return null;
        String t = s.trim();
        if (t.isEmpty()) return null;

        // Dates
        LocalDate d = tryParseDate(t);
        if (d != null) return d.toString();

        // Numbers
        String cleaned = t.replace(",", "");
        if (cleaned.startsWith("$")) cleaned = cleaned.substring(1);
        try {
            BigDecimal bd = new BigDecimal(cleaned);
            bd = bd.stripTrailingZeros();
            return bd.toPlainString();
        } catch (NumberFormatException ignore) {}

        // Strings
        return cleaned.replaceAll("\\s+", " ");
    }

    private static final List<DateTimeFormatter> DATE_FORMATS = List.of(
            DateTimeFormatter.ISO_LOCAL_DATE,
            DateTimeFormatter.ofPattern("M/d/uuuu"),
            DateTimeFormatter.ofPattern("MM/dd/uuuu"),
            DateTimeFormatter.ofPattern("M/d/uu"),
            DateTimeFormatter.ofPattern("MM/dd/uu")
    );

    private static LocalDate tryParseDate(String s) {
        for (var fmt : DATE_FORMATS) {
            try { return LocalDate.parse(s, fmt); }
            catch (DateTimeParseException ignore) {}
        }
        return null;
    }

    private static void writeSlimCsv(Path out, List<Map<String,String>> rows) throws IOException {
        CsvWriterSettings settings = new CsvWriterSettings();
        settings.setHeaderWritingEnabled(true);
        try (Writer w = Files.newBufferedWriter(out)) {
            CsvWriter writer = new CsvWriter(w, settings);
            writer.writeHeaders(OUTPUT_COLS.toArray(new String[0]));
            for (var r : rows) {
                List<String> line = new ArrayList<>(OUTPUT_COLS.size());
                for (String c : OUTPUT_COLS) line.add(r.getOrDefault(c, ""));
                writer.writeRow(line);
            }
            writer.close();
        }
    }
}
